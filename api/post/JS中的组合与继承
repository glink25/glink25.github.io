{"content":"{\"__ud_title\":\"JS中的组合与继承\",\"__ud_tags\":[],\"__ud_update_time\":1732152902975,\"__ud_create_time\":1732152882056,\"__ud_draft\":false,\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":1},\"content\":[{\"type\":\"text\",\"text\":\"JS中的组合与继承\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在前端开发中，有什么是继承可以做到而组合做不到的呢？\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"经典的EventTarget可以同时使用两种方式实现\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"// class\\nexport class EventEmitter {\\n    protected eventMap = new Map<string, Function[]>()\\n    on(name: string, callback: (...args: any[]) => void) {\\n        this.eventMap.set(name, [...this.eventMap.get(name) ?? [], callback])\\n    }\\n    off(name: string, callback: any) {\\n        this.eventMap.set(name, (this.eventMap.get(name) ?? []).filter(c => c !== callback))\\n    }\\n    emit(name: string, ...args: any[]) {\\n        this.eventMap.get(name)?.forEach((callback) => {\\n            callback(...args)\\n        })\\n    }\\n}\\n\\n// functional\\nexport const createEventEmitter = () => {\\n    const eventMap = new Map<string, Function[]>();\\n    const on = (name: string, callback: (...args: any[]) => void) => {\\n        eventMap.set(name, [...eventMap.get(name) ?? [], callback])\\n    }\\n    const off = (name: string, callback: any) => {\\n        eventMap.set(name, (eventMap.get(name) ?? []).filter(c => c !== callback))\\n    }\\n    const emit = (name: string, ...args: any[]) => {\\n        eventMap.get(name)?.forEach((callback) => {\\n            callback(...args)\\n        })\\n    }\\n\\n    return {\\n        on, off, emit\\n    }\\n}\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"看起来似乎都可以实现功能，只是换了种写法。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"现在考虑一个父类，除了eventEmitter功能之外，还需要一些别的功能：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"// class\\nexport class Parent extends EventEmitter {\\n    someMethod() { }\\n}\\n\\n// functional\\nexport const createParent = () => {\\n    const evenEmitter = createEventEmitter()\\n    const someMethod = () => { }\\n    return {\\n        ...evenEmitter,\\n        someMethod\\n    }\\n}\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"似乎依旧并无大碍，组合只是代码稍微多了一丢丢。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"那么继续，现在父类需要暴露自己所有已注册的监听器名称\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"export class Parent extends EventEmitter {\\n    someMethod() { }\\n    get eventNames(){\\n        return [...this.eventMap.keys()]\\n    }\\n}\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"于是，组合不适应的地方出现了。因为组合只有私有变量和公开变量（贴合class的说法），因此在多重嵌套下，要想用到内部某个函数的私有变量，只能从最底部开始，让其重新暴露出一个新的变量\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"export const createEventEmitter = () => {\\n\\t\\t// ...\\n    return {\\n\\t\\t// 将eventMap作为公开变量暴露出来\\n        on, off, emit, eventMap\\n    }\\n}\\n\\nexport const createParent = () => {\\n    const { on, off, emit, eventMap } = createEventEmitter()\\n    const someMethod = () => { }\\n    return {\\n        on, off, emit,\\n        someMethod,\\n        get eventNames() {\\n            return [...eventMap.keys()]\\n        }\\n    }\\n}\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"但是，这样的弊端就出现了，eventMap作为关键变量被危险地暴露了出来，现在这个组合不再安全，eventEMitter的eventMap可能会在其他地方被随意修改，监听器变得不再可靠。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"这只是一些特意举出来的例子，事实上如何使用组合与继承是一门哲学，并非完全的谁一定好于谁。在大多数情况下，某个对象并不会一层层地基于另一个对象，使用组合不仅能良好地组织代码，帮助梳理各个对象间的关系，还可以提高代码阅读效率，毕竟，组合天然就具有多继承的特性：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"export const createAnimal = () => {\\n    return {\\n        eat: () => {\\n            console.log('eat')\\n        }\\n    }\\n}\\n// 可以轻松实现Animal与EventMitter的“杂交”\\nexport const createParent = () => {\\n    const animal = createAnimal()\\n    const eventEmitter = createEventEmitter()\\n    const someMethod = () => { }\\n    return {\\n        ...eventEmitter,\\n        ...animal,\\n        someMethod\\n    }\\n}\\n\\n// Error, Javascript不支持多继承\\nexport class Parent extends EventEmitter, Animal {\\n    someMethod() { }\\n    get eventNames() {\\n        return [...this.eventMap.keys()]\\n    }\\n}\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"换句话说，组合更适合于平铺，适合于把多个解决方法合并起来；而继承适合嵌套，更多用在概念上的层层递进。当然，这里仅限于Javascript，因为Javascript天然没有多继承。\"}]}]}","title":"JS中的组合与继承","tags":[],"updateTime":1732152902975,"createTime":1732152882056,"draft":false,"intro":"在前端开发中，有什么是继承可以做到而组合做不到的呢？","html":"<h1>JS中的组合与继承</h1><p>在前端开发中，有什么是继承可以做到而组合做不到的呢？</p><p>经典的EventTarget可以同时使用两种方式实现</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-comment\" class=\"hljs-comment\">// class</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">class</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">EventEmitter</span> {\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">protected</span> eventMap = <span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Map</span>&lt;<span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span>, <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Function</span>[]&gt;()\n    <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">on</span>(<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\" class=\"hljs-attr\">callback</span>: (...args: <span class=\"hljs-built_in\" class=\"hljs-built_in\">any</span>[]) =&gt; <span class=\"hljs-built_in\" class=\"hljs-built_in\">void</span></span>) {\n        <span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">this</span>.<span class=\"hljs-property\" class=\"hljs-property\">eventMap</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">set</span>(name, [...<span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">this</span>.<span class=\"hljs-property\" class=\"hljs-property\">eventMap</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">get</span>(name) ?? [], callback])\n    }\n    <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">off</span>(<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\" class=\"hljs-attr\">callback</span>: <span class=\"hljs-built_in\" class=\"hljs-built_in\">any</span></span>) {\n        <span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">this</span>.<span class=\"hljs-property\" class=\"hljs-property\">eventMap</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">set</span>(name, (<span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">this</span>.<span class=\"hljs-property\" class=\"hljs-property\">eventMap</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">get</span>(name) ?? []).<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">filter</span>(<span class=\"hljs-function\" class=\"hljs-function\"><span class=\"hljs-params\" class=\"hljs-params\">c</span> =&gt;</span> c !== callback))\n    }\n    <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">emit</span>(<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span>, ...<span class=\"hljs-attr\" class=\"hljs-attr\">args</span>: <span class=\"hljs-built_in\" class=\"hljs-built_in\">any</span>[]</span>) {\n        <span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">this</span>.<span class=\"hljs-property\" class=\"hljs-property\">eventMap</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">get</span>(name)?.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">forEach</span>(<span class=\"hljs-function\" class=\"hljs-function\">(<span class=\"hljs-params\" class=\"hljs-params\">callback</span>) =&gt;</span> {\n            <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">callback</span>(...args)\n        })\n    }\n}\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">// functional</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createEventEmitter</span> = (<span class=\"hljs-params\" class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> eventMap = <span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Map</span>&lt;<span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span>, <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Function</span>[]&gt;();\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">on</span> = (<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\" class=\"hljs-attr\">callback</span>: (...args: <span class=\"hljs-built_in\" class=\"hljs-built_in\">any</span>[]) =&gt; <span class=\"hljs-built_in\" class=\"hljs-built_in\">void</span></span>) =&gt; {\n        eventMap.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">set</span>(name, [...eventMap.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">get</span>(name) ?? [], callback])\n    }\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">off</span> = (<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\" class=\"hljs-attr\">callback</span>: <span class=\"hljs-built_in\" class=\"hljs-built_in\">any</span></span>) =&gt; {\n        eventMap.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">set</span>(name, (eventMap.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">get</span>(name) ?? []).<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">filter</span>(<span class=\"hljs-function\" class=\"hljs-function\"><span class=\"hljs-params\" class=\"hljs-params\">c</span> =&gt;</span> c !== callback))\n    }\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">emit</span> = (<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">name</span>: <span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span>, ...<span class=\"hljs-attr\" class=\"hljs-attr\">args</span>: <span class=\"hljs-built_in\" class=\"hljs-built_in\">any</span>[]</span>) =&gt; {\n        eventMap.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">get</span>(name)?.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">forEach</span>(<span class=\"hljs-function\" class=\"hljs-function\">(<span class=\"hljs-params\" class=\"hljs-params\">callback</span>) =&gt;</span> {\n            <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">callback</span>(...args)\n        })\n    }\n\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> {\n        on, off, emit\n    }\n}\n</code></pre></div></div><p>看起来似乎都可以实现功能，只是换了种写法。</p><p>现在考虑一个父类，除了eventEmitter功能之外，还需要一些别的功能：</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-comment\" class=\"hljs-comment\">// class</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">class</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Parent</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">extends</span> <span class=\"hljs-title,class_,inherited__\" class=\"hljs-title,class_,inherited__\">EventEmitter</span> {\n    <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">someMethod</span>(<span class=\"hljs-params\" class=\"hljs-params\"></span>) { }\n}\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">// functional</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createParent</span> = (<span class=\"hljs-params\" class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> evenEmitter = <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createEventEmitter</span>()\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">someMethod</span> = (<span class=\"hljs-params\" class=\"hljs-params\"></span>) =&gt; { }\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> {\n        ...evenEmitter,\n        someMethod\n    }\n}\n</code></pre></div></div><p>似乎依旧并无大碍，组合只是代码稍微多了一丢丢。</p><p>那么继续，现在父类需要暴露自己所有已注册的监听器名称</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">class</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Parent</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">extends</span> <span class=\"hljs-title,class_,inherited__\" class=\"hljs-title,class_,inherited__\">EventEmitter</span> {\n    <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">someMethod</span>(<span class=\"hljs-params\" class=\"hljs-params\"></span>) { }\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">get</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">eventNames</span>(){\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> [...<span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">this</span>.<span class=\"hljs-property\" class=\"hljs-property\">eventMap</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">keys</span>()]\n    }\n}\n</code></pre></div></div><p>于是，组合不适应的地方出现了。因为组合只有私有变量和公开变量（贴合class的说法），因此在多重嵌套下，要想用到内部某个函数的私有变量，只能从最底部开始，让其重新暴露出一个新的变量</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createEventEmitter</span> = (<span class=\"hljs-params\" class=\"hljs-params\"></span>) =&gt; {\n\t\t<span class=\"hljs-comment\" class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> {\n\t\t<span class=\"hljs-comment\" class=\"hljs-comment\">// 将eventMap作为公开变量暴露出来</span>\n        on, off, emit, eventMap\n    }\n}\n\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createParent</span> = (<span class=\"hljs-params\" class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> { on, off, emit, eventMap } = <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createEventEmitter</span>()\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">someMethod</span> = (<span class=\"hljs-params\" class=\"hljs-params\"></span>) =&gt; { }\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> {\n        on, off, emit,\n        someMethod,\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">get</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">eventNames</span>() {\n            <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> [...eventMap.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">keys</span>()]\n        }\n    }\n}\n</code></pre></div></div><p>但是，这样的弊端就出现了，eventMap作为关键变量被危险地暴露了出来，现在这个组合不再安全，eventEMitter的eventMap可能会在其他地方被随意修改，监听器变得不再可靠。</p><p>这只是一些特意举出来的例子，事实上如何使用组合与继承是一门哲学，并非完全的谁一定好于谁。在大多数情况下，某个对象并不会一层层地基于另一个对象，使用组合不仅能良好地组织代码，帮助梳理各个对象间的关系，还可以提高代码阅读效率，毕竟，组合天然就具有多继承的特性：</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createAnimal</span> = (<span class=\"hljs-params\" class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> {\n        <span class=\"hljs-attr\" class=\"hljs-attr\">eat</span>: <span class=\"hljs-function\" class=\"hljs-function\">() =&gt;</span> {\n            <span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">console</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">log</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;eat&apos;</span>)\n        }\n    }\n}\n<span class=\"hljs-comment\" class=\"hljs-comment\">// 可以轻松实现Animal与EventMitter的“杂交”</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createParent</span> = (<span class=\"hljs-params\" class=\"hljs-params\"></span>) =&gt; {\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> animal = <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createAnimal</span>()\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> eventEmitter = <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createEventEmitter</span>()\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">someMethod</span> = (<span class=\"hljs-params\" class=\"hljs-params\"></span>) =&gt; { }\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> {\n        ...eventEmitter,\n        ...animal,\n        someMethod\n    }\n}\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">// Error, Javascript不支持多继承</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">class</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Parent</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">extends</span> <span class=\"hljs-title,class_,inherited__\" class=\"hljs-title,class_,inherited__\">EventEmitter</span>, <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Animal</span> {\n    <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">someMethod</span>(<span class=\"hljs-params\" class=\"hljs-params\"></span>) { }\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">get</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">eventNames</span>() {\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> [...<span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">this</span>.<span class=\"hljs-property\" class=\"hljs-property\">eventMap</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">keys</span>()]\n    }\n}\n</code></pre></div></div><p>换句话说，组合更适合于平铺，适合于把多个解决方法合并起来；而继承适合嵌套，更多用在概念上的层层递进。当然，这里仅限于Javascript，因为Javascript天然没有多继承。</p><script type=\"module\">const injectHtml = (root, html) => {\n  const iframe = document.createElement(\"iframe\");\n  const htmlContent = `<html><head></head><body>${html}</body></html>`;\n  iframe.style.width = \"100%\";\n  iframe.style.height = \"100%\";\n  iframe.onload = () => {\n    const doc = iframe.contentDocument || iframe.contentWindow?.document;\n    if (!doc) {\n      return;\n    }\n    doc.open();\n    doc.write(htmlContent);\n    doc.close();\n  };\n  root.replaceChildren(iframe);\n}\n  document.querySelectorAll('.playground')?.forEach(el=>{\n    const html = el.getAttribute('data-html');\n    if (html) {\n      injectHtml(el,html);\n    }\n    const indicator = document.createElement(\"div\");\n    indicator.className = \"indicator\";\n    const showCode = document.createElement(\"div\");\n    showCode.className = \"show-code\";\n    showCode.innerText = \"code\";\n    showCode.onclick = () => {\n      el.parentElement.classList.remove(\"preview-only\");\n    };\n    const showPreview = document.createElement(\"div\");\n    showPreview.className = \"show-preview\";\n    showPreview.innerText = \"preview\";\n    showPreview.onclick = () => {\n      el.parentElement.classList.add(\"preview-only\");\n    };\n    indicator.appendChild(showCode);\n    indicator.appendChild(showPreview);\n    el.parentElement.appendChild(indicator);\n    if (window.screen.width < 768) {\n      showPreview.click();\n    }\n  });</script>","id":"JS中的组合与继承","path":"/posts/JS中的组合与继承.json"}