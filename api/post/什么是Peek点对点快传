{"content":"{\"__ud_title\":\"什么是Peek｜点对点快传\",\"__ud_tags\":[\"Peek\"],\"__ud_update_time\":1732152836752,\"__ud_create_time\":1732008475528,\"__ud_draft\":false,\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":1},\"content\":[{\"type\":\"text\",\"text\":\"什么是Peek｜点对点快传\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"通俗点说，\"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://peek-transfer.github.io/\",\"target\":\"_blank\",\"rel\":\"noreferer\",\"class\":null}}],\"text\":\"Peek\"},{\"type\":\"text\",\"text\":\" 是一个简易的数据传输工具，它基于WebRTC进行点对点的数据通讯，并在此基础上实现聊天、音视频通话、文件传输等。得益于peerjs项目的杰出贡献，它抹去了大部分的WebRTC底层实现，使得此项目能专注于传输界面和功能的实现，并且通过peerjs的官方STUN服务器实现NAT穿透，使得Peek无需服务器也能正常使用，成为一个纯粹的静态前端SPA项目。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Peek的开发过程历时悠久，尽管1.0版本在很早以前就被我已经发布在了github上，但是比较简陋，代码结构也比较随意。随着工程经验的增加，我决定对初版Peek进行一次全方位重构，并为其增加更多功能。在重构的过程中，我梳理出了一些可以复用的经验，并记录在此专栏中。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"由于我的技术栈以Vue为主，因此此次对Peek的优化也可以看作是一次对Vue3项目最佳实践的探索，在此之前，由于经常使用Vue2带来的思维惯性，以及对Element UI的大量使用导致部分组件化思维的固化，有许多代码结构在Vue3框架下显得臃肿且多余；同时，在经历了大量TS类型体操的训练之后，我对Typescript的了解也逐步加深，因此将当前对部分优化过程的思考放在这里，供日后查看精进。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":1},\"content\":[{\"type\":\"text\",\"text\":\"从搭建项目开始\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":1},\"content\":[{\"type\":\"text\",\"text\":\"构建工具\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"毋庸置疑地说，在Vite 1.0版本发布之后的新项目，都应该使用Vite来搭建，这是我在第一次体验到Vite开发后最大的感受，更不用说目前Vite已经更新到了4.0版本，跟Webpack比起来在开发体验上好了太多，因此Peek从一开始就选择了使用Vite作为构建工具。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":1},\"content\":[{\"type\":\"text\",\"text\":\"构建插件\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"我在Peek中选择的构建插件主要如下：\"}]},{\"type\":\"bulletList\",\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"UnoCSS\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Sass\"}]}]}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"UnoCSS是一个原子化CSS项目，和它的前辈TailwindCSS、WindiCSS一样，它可以使用组合类名来代替具体的类名+手写CSS。虽然看起来有点像开Bootstrap之流的历史倒车，但是得益于新的动态生成和按需加载技术，使用现代的原子化CSS得到的CSS代码体积要比单纯引入一个超大的bootstrap.css文件要小得多，并且拓展性更强，更重要的是，虽然看起来写多个原子式的类名比只写一个类名要打更多的字，但实际体验上比起不停地在style块和html块里来回切换，只靠阅读html就能知道并修改样式要舒服得多。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在实践中，Peek几乎完全使用原子类名来撰写样式，而Sass只是在部分情况下，例如多重父子选择器和通用组件样式覆盖这类情况下使用，归根结底是为了更好的样式书写体验。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"我没有使用auto-import这类的插件，一方面是我担心在某些情况下，自动引入可能会导致打包时的tree-shaking失效，另一方面是使用自动引入的Vue组件会失去对props的自动提示，得不偿失。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"值得注意的是，我在项目中使用到了UnoCSS的Iconify图标插件，通过这个插件，我可以在类名中直接使用如“i-mdi:icon-named”的方式来使用Iconify中的图标，十分方便。不过，在部分Node.js版本中，直接使用“import(’xxx.json’)”的方式来引入json文件可能会因为Node版本不支持动态引入JSON文件而报错，\"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"http://可以手写一个使用fs.read\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer nofollow\",\"class\":null}}],\"text\":\"可以手写一个使用fs.read\"},{\"type\":\"text\",\"text\":\"的readJson方法来代替：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"const readJsonFile = async (path: string) =>\\n  JSON.parse(\\n    await readFile(\\n      resolve(__dirname, `./node_modules/${path}`), { encoding: 'utf-8' }\\n    )\\n  )\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"UnoCSS其实也支持在CSS中使用如“@apply bg-red;”这种方式来嵌入预设的样式，只是需要手动开启：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"import { defineConfig, Plugin, loadEnv } from 'vite'\\nimport UnoCSS from \\\"unocss/vite\\\";\\nimport { presetIcons, transformerDirectives, presetWind } from \\\"unocss\\\";\\n\\nexport default defineConfig({\\n\\tplugins:[\\n\\t\\tUnoCSS({\\n      presets: [\\n        presetWind(),\\n        presetIcons({\\n          collections: {\\n            material: () => readJsonFile('@iconify-json/mdi/icons.json').then(i => i.default),\\n          }\\n        }),\\n      ],\\n\\t\\t\\t// 在这里来应用指令语法\\n      transformers: [transformerDirectives()]\\n    }),\\n\\t]\\n})\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"另外，由于项目中会使用到WebRTC与音视频录制，所以需要在安全的浏览器上下文环境中才能调用此类API，因此需要使用 vite-plugin-mkcert 插件来启用https证书支持。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":1},\"content\":[{\"type\":\"text\",\"text\":\"更好的Typescript支持\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"如果使用create-vite选择vue+ts模板搭建项目的话，就已经可以得到完整的typescript支持了，不过为了更好的开发体验，还是可以增加一些设置。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"TS的“alias”可以让我们为文件夹设置别名，例如将“src”文件夹设置为“@”，这样可以方便从各个不同的文件夹中引入函数时省去开头的一堆“../../”，提升代码阅读体验，也能把各个文件的依赖看的一目了然。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在tsconfig.json中：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"json\"},\"content\":[{\"type\":\"text\",\"text\":\"{\\n  \\\"compilerOptions\\\": {\\n    \\\"paths\\\": {\\n      \\\"@/*\\\": [\\n        \\\"./src/*\\\"\\n      ]\\n    },\\n  },\\n}\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"这样ts就可以自动提示和自动引入了，不过vite还不能识别，需要在vite.config.ts中配置：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"export default defineConfig(({ mode }) => ({\\n\\t// ...others\\n  resolve: {\\n    alias: {\\n      '@': path.resolve(__dirname, './src'),\\n    },\\n  },\\n}))\\n\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":1},\"content\":[{\"type\":\"text\",\"text\":\"Lint & Formatter\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"对于需要团队合作或者有着代码强迫症的人来说，lint是一个好选择，但目前来说，我还没有找到一个eslint、prettier和volar之间能够完美合作的配置，要不然是格式化时冲突，要不然就是代码提示疯狂跳舞，每次保存都让你无法预料到底走的是哪一套规则，所以我的建议是，都不用。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"除了Vue文件使用Volar之外，其余的让VS Code自己决定去吧。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":1},\"content\":[{\"type\":\"text\",\"text\":\"影子路由\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"对于Peek这样简单的SPA来说，router其实是可有可无的，因为它总共只有两个页面，上router似乎有点杀鸡用牛刀的感觉，但router的作用其实不止于此。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在我看来，router其实是一种组件组织方式，它并不只是一个路由工具，强依附于url，而是自成体系，与url无关。通过router，我们可以将多个页面拆分成框架+内容的模式，并通过router的父子关系将它们组合起来。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"router的children往往给人一种错觉，让人觉得router配置的形状就代表了页面真实的路由形状，虽然大多数情况下确实如此，但其实两者之并没有紧密的联系。\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"// router.ts\\nconst routes: RouteRecordRaw[] = [\\n    {\\n        path: '/',\\n\\t\\t\\t\\tredirect: '/personal',\\n        component: () => import('@/views/HomeLayout.vue'),\\n\\t\\t\\t\\tchildren:[\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t        path: '/personal',\\n\\t\\t\\t        component: () => import('@/views/Personal.vue')\\n\\t\\t\\t    },\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t        path: '/discover',\\n\\t\\t\\t        component: () => import('@/views/Discover.vue')\\n\\t\\t\\t    }\\n\\t\\t\\t\\t]\\n    },\\n    {\\n        path: '/chat',\\n        component: () => import('@/views/Chat.vue')\\n    }\\n]\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"如上面的例子所示，很容易让人觉得 / 和 /chat 是同级关系，而 /personal /discover是 / 下的子路由，然而事实上，/personal /discover /chat其实是三个平级关系，页面中并不存在 / 这个路由，它只是起了一个容器的作用，告知router-view在渲染时，将HomeLayout作为框架组件，然后再根据路由的不同为HomeLayout分配不同的子组件。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"一旦理解了这层含义，就能清楚地认识到，router的本质其实是一个组件嵌套工具，通过它我们可以方便地整理出页面的拼装方式，并反应到router配置中。因此，vue-router团队特意将router的history抽离成插件的形式，因为当我们使用createWebHashHistory时，我们只是选用了浏览器url这种方式来显示地展示当前的页面标识符。如果我们并不希望展示出来，例如为了防止用户错误地前进后退到意外的路由，我们可以使用createMemoryHistory，将路由信息保存到内存中，这样，我们就摆脱了浏览器网址的限制，同时依然享受router带来的便利。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"比起手动使用v-if方式来切换组件，router的好处多了太多：\"}]},{\"type\":\"bulletList\",\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"开箱即用的组件懒加载\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"进入和离开守卫，防止错误地进入某些页面\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"方便的过渡效果\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"直观的页面组织方式\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"命令式地跳转\"}]}]}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"关于最后一点，我相信应该有很多人都深有体会。虽然Vue的设计哲学是声明式地编写界面，但是某些情况下，命令式地调用函数往往比修改某个响应式变量的值要舒服的多。例如当我们要在某个嵌套得很深的子组件内切换页面时，使用v-if需要我们把事件穿过层层组件上报给父组件，或者把父组件的方法provide下去，这样往往会增加组件间的耦合性，更好的做法是使用全局store或者Vue3的hooks把currentPage拆分到独立的文件中，于是在考虑了许多边界条件之后，我们兴奋地发现，我们重新实现了router。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":1},\"content\":[{\"type\":\"text\",\"text\":\"异步，异步，不择手段地异步\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Peek的核心是基于peerjs的数据通讯系统，而peerjs的api是基于监听器的，如果直接基于peerjs编写传输功能，会消耗大量的时间在检查监听器设置是否正确，以及判断各种边界条件上，并且整个peerjs实例会在各个组件中被用来用去，不利于后续bug排查，也很容易导致冲突，因此对peerjs进行封装很有必要。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在封装的设计上，我把整个数据通讯模块分为了两个部分，第一个部分为通讯主体，它负责处理通讯握手阶段，然后在握手成功后将peerjs实例和连接实例传递给插件使用；第二个部分为插件，它们会在握手成功后被初始化，并根据自身用途调用peerjs相关的api，例如发生消息，进行通话等。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"先来看握手阶段，由于peerjs的connect方法是直接建立连接，并没有用户确认的过程，因此我们需要在此之上模拟一层用户手动确认的过程，即需要被连接的用户向发起者发送确认信息，才能进入真正的聊天阶段。因此，这里需要用到许多监听器，但是这样会导致组件产生太多业务无关的代码，我希望组件能专注界面展现，需要一个便捷的接口来实现这一点：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"// 伪代码展示Peek的使用\\n// 主动连接\\nconst connect = async (id:string, info:any) => {\\n\\tconst accepted = peek.connect(id, info);\\n\\ttry{\\n\\t\\tawait accepted;\\n\\t\\tconsole.log(\\\"connect success\\\")\\n\\t}catch{\\n\\t\\tconsole.log(\\\"connect rejected\\\")\\n\\t}\\n}\\n\\n// 被动连接\\npeek.onBeRequest( async (info:any, accept, reject) => {\\n\\ttry{\\n\\t\\tawait confirm(`${info.name} wants to connect with you, confirm?`)\\n\\t\\taccept()\\n\\t}catch{\\n\\t\\treject()\\n\\t}\\n})\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"我们把整个握手过程抽象成一次异步调用过程，极大地降低了理解成本，也减少了在组件中插入的非业务代码，让组件专注于UI处理。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"不过，最终功能的完成还是少不了监听器的，脏活还是要交给peek内部来实现\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"// Peek内部实现伪代码\\nconst createPeek=()=>{\\n\\tconst peer=new Peer();\\n\\n\\tconst connect=(id:string, info:any)=>{\\n\\t\\tconst connection=peer.connect(id, {metadata:info})\\n\\t\\treturn new Promise((res, rej)=>{\\n\\t\\t\\t// 监听收到的信息\\n\\t\\t\\tconnection.once('data', (data)=>{\\n\\t\\t\\t\\tif(data==='accept'){\\n\\t\\t\\t\\t\\tres()\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\trej()\\n\\t\\t\\t\\t\\tconnection.close()\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t})\\n\\t}\\n\\n\\tconst onBeRequest=(fn:(info:any, accept:Function ,reject:Function)=>void)=>{\\n\\t\\tpeer.on('connection', (connection)=>{\\n\\t\\t\\tconst info = connection.metadata\\n\\t\\t\\tconst accpet=()=>{\\n\\t\\t\\t\\t// 发送确认信息\\n\\t\\t\\t\\tconnection.send('accept')\\n\\t\\t\\t}\\n\\t\\t\\tconst reject=()=>{\\n\\t\\t\\t\\t// 发送拒绝信息并关闭连接\\n\\t\\t\\t\\tconnection.send('reject')\\n\\t\\t\\t\\tconnection.close()\\n\\t\\t\\t}\\n\\t\\t\\tfn(info, accept, reject)\\n\\t\\t})\\n\\t}\\n\\treturn {\\n\\t\\tconnect,\\n\\t\\tonBeRequest,\\n\\t}\\n}\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"这里省去了许多peerjs的api用法展示，主要专注于整套握手逻辑的实现，使用promise搭配监听器，将原本的监听过程变为异步的等待过程，降低了代码复杂度，并易于理解。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"这样的思想也贯穿在后续插件的设计中，比如Message插件，需要实现消息发送成功的回调，也同样用到了类似的方法。Call插件的异步则较为复杂，因为音视频通话还存在一个中途取消的过程，所以用到的监听器和判断条件也更多，再加上peerjs本身还存在一些未解决的bug，导致Call插件的实现逻辑更为复杂，不过依然保持了业务分离原则，让组件保持尽可能地纯粹。\"}]}]}","title":"什么是Peek｜点对点快传","tags":["Peek"],"updateTime":1732152836752,"createTime":1732008475528,"draft":false,"intro":"通俗点说，Peek 是一个简易的数据传输工具，它基于WebRTC进行点对点的数据通讯，并在此基础上实现聊天、音视频通话、文件传输等。得益于peerjs项目的杰出贡献，它抹去了大部分的WebRTC底层实现，使得此项目能专注于传输界面和功能的实现，并且通过peerjs的官方STUN服务器实现NAT穿透，使得Peek无需服务器也能正常使用，成为一个纯粹的静态前端SPA项目。","html":"<h1 level=\"1\">什么是Peek｜点对点快传</h1><p>通俗点说，<a target=\"_blank\" rel=\"noreferer\" href=\"https://peek-transfer.github.io/\">Peek</a> 是一个简易的数据传输工具，它基于WebRTC进行点对点的数据通讯，并在此基础上实现聊天、音视频通话、文件传输等。得益于peerjs项目的杰出贡献，它抹去了大部分的WebRTC底层实现，使得此项目能专注于传输界面和功能的实现，并且通过peerjs的官方STUN服务器实现NAT穿透，使得Peek无需服务器也能正常使用，成为一个纯粹的静态前端SPA项目。</p><p>Peek的开发过程历时悠久，尽管1.0版本在很早以前就被我已经发布在了github上，但是比较简陋，代码结构也比较随意。随着工程经验的增加，我决定对初版Peek进行一次全方位重构，并为其增加更多功能。在重构的过程中，我梳理出了一些可以复用的经验，并记录在此专栏中。</p><p>由于我的技术栈以Vue为主，因此此次对Peek的优化也可以看作是一次对Vue3项目最佳实践的探索，在此之前，由于经常使用Vue2带来的思维惯性，以及对Element UI的大量使用导致部分组件化思维的固化，有许多代码结构在Vue3框架下显得臃肿且多余；同时，在经历了大量TS类型体操的训练之后，我对Typescript的了解也逐步加深，因此将当前对部分优化过程的思考放在这里，供日后查看精进。</p><h1 level=\"1\">从搭建项目开始</h1><h1 level=\"1\">构建工具</h1><p>毋庸置疑地说，在Vite 1.0版本发布之后的新项目，都应该使用Vite来搭建，这是我在第一次体验到Vite开发后最大的感受，更不用说目前Vite已经更新到了4.0版本，跟Webpack比起来在开发体验上好了太多，因此Peek从一开始就选择了使用Vite作为构建工具。</p><h1 level=\"1\">构建插件</h1><p>我在Peek中选择的构建插件主要如下：</p><ul><li><p>UnoCSS</p></li><li><p>Sass</p></li></ul><p>UnoCSS是一个原子化CSS项目，和它的前辈TailwindCSS、WindiCSS一样，它可以使用组合类名来代替具体的类名+手写CSS。虽然看起来有点像开Bootstrap之流的历史倒车，但是得益于新的动态生成和按需加载技术，使用现代的原子化CSS得到的CSS代码体积要比单纯引入一个超大的bootstrap.css文件要小得多，并且拓展性更强，更重要的是，虽然看起来写多个原子式的类名比只写一个类名要打更多的字，但实际体验上比起不停地在style块和html块里来回切换，只靠阅读html就能知道并修改样式要舒服得多。</p><p>在实践中，Peek几乎完全使用原子类名来撰写样式，而Sass只是在部分情况下，例如多重父子选择器和通用组件样式覆盖这类情况下使用，归根结底是为了更好的样式书写体验。</p><p>我没有使用auto-import这类的插件，一方面是我担心在某些情况下，自动引入可能会导致打包时的tree-shaking失效，另一方面是使用自动引入的Vue组件会失去对props的自动提示，得不偿失。</p><p>值得注意的是，我在项目中使用到了UnoCSS的Iconify图标插件，通过这个插件，我可以在类名中直接使用如“i-mdi:icon-named”的方式来使用Iconify中的图标，十分方便。不过，在部分Node.js版本中，直接使用“import(’xxx.json’)”的方式来引入json文件可能会因为Node版本不支持动态引入JSON文件而报错，<a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"http://可以手写一个使用fs.read\">可以手写一个使用fs.read</a>的readJson方法来代替：</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">readJsonFile</span> = <span class=\"hljs-keyword\" class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">path</span>: <span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span></span>) =&gt;\n  <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">JSON</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">parse</span>(\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">await</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">readFile</span>(\n      <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">resolve</span>(__dirname, <span class=\"hljs-string\" class=\"hljs-string\">`./node_modules/<span class=\"hljs-subst\" class=\"hljs-subst\">${path}</span>`</span>), { <span class=\"hljs-attr\" class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\" class=\"hljs-string\">&apos;utf-8&apos;</span> }\n    )\n  )\n</code></pre></div></div><p>UnoCSS其实也支持在CSS中使用如“@apply bg-red;”这种方式来嵌入预设的样式，只是需要手动开启：</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> { defineConfig, <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Plugin</span>, loadEnv } <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&apos;vite&apos;</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">UnoCSS</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;unocss/vite&quot;</span>;\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> { presetIcons, transformerDirectives, presetWind } <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;unocss&quot;</span>;\n\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">default</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">defineConfig</span>({\n\t<span class=\"hljs-attr\" class=\"hljs-attr\">plugins</span>:[\n\t\t<span class=\"hljs-title,class_\" class=\"hljs-title,class_\">UnoCSS</span>({\n      <span class=\"hljs-attr\" class=\"hljs-attr\">presets</span>: [\n        <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">presetWind</span>(),\n        <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">presetIcons</span>({\n          <span class=\"hljs-attr\" class=\"hljs-attr\">collections</span>: {\n            <span class=\"hljs-attr\" class=\"hljs-attr\">material</span>: <span class=\"hljs-function\" class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">readJsonFile</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;@iconify-json/mdi/icons.json&apos;</span>).<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">then</span>(<span class=\"hljs-function\" class=\"hljs-function\"><span class=\"hljs-params\" class=\"hljs-params\">i</span> =&gt;</span> i.<span class=\"hljs-property\" class=\"hljs-property\">default</span>),\n          }\n        }),\n      ],\n\t\t\t<span class=\"hljs-comment\" class=\"hljs-comment\">// 在这里来应用指令语法</span>\n      <span class=\"hljs-attr\" class=\"hljs-attr\">transformers</span>: [<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">transformerDirectives</span>()]\n    }),\n\t]\n})\n</code></pre></div></div><p>另外，由于项目中会使用到WebRTC与音视频录制，所以需要在安全的浏览器上下文环境中才能调用此类API，因此需要使用 vite-plugin-mkcert 插件来启用https证书支持。</p><h1 level=\"1\">更好的Typescript支持</h1><p>如果使用create-vite选择vue+ts模板搭建项目的话，就已经可以得到完整的typescript支持了，不过为了更好的开发体验，还是可以增加一些设置。</p><p>TS的“alias”可以让我们为文件夹设置别名，例如将“src”文件夹设置为“@”，这样可以方便从各个不同的文件夹中引入函数时省去开头的一堆“../../”，提升代码阅读体验，也能把各个文件的依赖看的一目了然。</p><p>在tsconfig.json中：</p><div class=\"llt-code readonly\"><div class=\"language\">json</div><div class=\"wrapper\"><pre><code class=\"language-json\"><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\" class=\"hljs-attr\">&quot;compilerOptions&quot;</span><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\" class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\" class=\"hljs-attr\">&quot;paths&quot;</span><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\" class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\" class=\"hljs-attr\">&quot;@/*&quot;</span><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\" class=\"hljs-punctuation\">[</span>\n        <span class=\"hljs-string\" class=\"hljs-string\">&quot;./src/*&quot;</span>\n      <span class=\"hljs-punctuation\" class=\"hljs-punctuation\">]</span>\n    <span class=\"hljs-punctuation\" class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-punctuation\" class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-punctuation\" class=\"hljs-punctuation\">}</span>\n</code></pre></div></div><p>这样ts就可以自动提示和自动引入了，不过vite还不能识别，需要在vite.config.ts中配置：</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">default</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">defineConfig</span>(<span class=\"hljs-function\" class=\"hljs-function\">(<span class=\"hljs-params\" class=\"hljs-params\">{ mode }</span>) =&gt;</span> ({\n\t<span class=\"hljs-comment\" class=\"hljs-comment\">// ...others</span>\n  <span class=\"hljs-attr\" class=\"hljs-attr\">resolve</span>: {\n    <span class=\"hljs-attr\" class=\"hljs-attr\">alias</span>: {\n      <span class=\"hljs-string\" class=\"hljs-string\">&apos;@&apos;</span>: path.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">resolve</span>(__dirname, <span class=\"hljs-string\" class=\"hljs-string\">&apos;./src&apos;</span>),\n    },\n  },\n}))\n</code></pre></div></div><h1 level=\"1\">Lint &amp; Formatter</h1><p>对于需要团队合作或者有着代码强迫症的人来说，lint是一个好选择，但目前来说，我还没有找到一个eslint、prettier和volar之间能够完美合作的配置，要不然是格式化时冲突，要不然就是代码提示疯狂跳舞，每次保存都让你无法预料到底走的是哪一套规则，所以我的建议是，都不用。</p><p>除了Vue文件使用Volar之外，其余的让VS Code自己决定去吧。</p><h1 level=\"1\">影子路由</h1><p>对于Peek这样简单的SPA来说，router其实是可有可无的，因为它总共只有两个页面，上router似乎有点杀鸡用牛刀的感觉，但router的作用其实不止于此。</p><p>在我看来，router其实是一种组件组织方式，它并不只是一个路由工具，强依附于url，而是自成体系，与url无关。通过router，我们可以将多个页面拆分成框架+内容的模式，并通过router的父子关系将它们组合起来。</p><p>router的children往往给人一种错觉，让人觉得router配置的形状就代表了页面真实的路由形状，虽然大多数情况下确实如此，但其实两者之并没有紧密的联系。</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-comment\" class=\"hljs-comment\">// router.ts</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\" class=\"hljs-attr\">routes</span>: <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">RouteRecordRaw</span>[] = [\n    {\n        <span class=\"hljs-attr\" class=\"hljs-attr\">path</span>: <span class=\"hljs-string\" class=\"hljs-string\">&apos;/&apos;</span>,\n\t\t\t\t<span class=\"hljs-attr\" class=\"hljs-attr\">redirect</span>: <span class=\"hljs-string\" class=\"hljs-string\">&apos;/personal&apos;</span>,\n        <span class=\"hljs-attr\" class=\"hljs-attr\">component</span>: <span class=\"hljs-function\" class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;@/views/HomeLayout.vue&apos;</span>),\n\t\t\t\t<span class=\"hljs-attr\" class=\"hljs-attr\">children</span>:[\n\t\t\t\t\t{\n\t\t\t        <span class=\"hljs-attr\" class=\"hljs-attr\">path</span>: <span class=\"hljs-string\" class=\"hljs-string\">&apos;/personal&apos;</span>,\n\t\t\t        <span class=\"hljs-attr\" class=\"hljs-attr\">component</span>: <span class=\"hljs-function\" class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;@/views/Personal.vue&apos;</span>)\n\t\t\t    },\n\t\t\t\t\t{\n\t\t\t        <span class=\"hljs-attr\" class=\"hljs-attr\">path</span>: <span class=\"hljs-string\" class=\"hljs-string\">&apos;/discover&apos;</span>,\n\t\t\t        <span class=\"hljs-attr\" class=\"hljs-attr\">component</span>: <span class=\"hljs-function\" class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;@/views/Discover.vue&apos;</span>)\n\t\t\t    }\n\t\t\t\t]\n    },\n    {\n        <span class=\"hljs-attr\" class=\"hljs-attr\">path</span>: <span class=\"hljs-string\" class=\"hljs-string\">&apos;/chat&apos;</span>,\n        <span class=\"hljs-attr\" class=\"hljs-attr\">component</span>: <span class=\"hljs-function\" class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;@/views/Chat.vue&apos;</span>)\n    }\n]\n</code></pre></div></div><p>如上面的例子所示，很容易让人觉得 / 和 /chat 是同级关系，而 /personal /discover是 / 下的子路由，然而事实上，/personal /discover /chat其实是三个平级关系，页面中并不存在 / 这个路由，它只是起了一个容器的作用，告知router-view在渲染时，将HomeLayout作为框架组件，然后再根据路由的不同为HomeLayout分配不同的子组件。</p><p>一旦理解了这层含义，就能清楚地认识到，router的本质其实是一个组件嵌套工具，通过它我们可以方便地整理出页面的拼装方式，并反应到router配置中。因此，vue-router团队特意将router的history抽离成插件的形式，因为当我们使用createWebHashHistory时，我们只是选用了浏览器url这种方式来显示地展示当前的页面标识符。如果我们并不希望展示出来，例如为了防止用户错误地前进后退到意外的路由，我们可以使用createMemoryHistory，将路由信息保存到内存中，这样，我们就摆脱了浏览器网址的限制，同时依然享受router带来的便利。</p><p>比起手动使用v-if方式来切换组件，router的好处多了太多：</p><ul><li><p>开箱即用的组件懒加载</p></li><li><p>进入和离开守卫，防止错误地进入某些页面</p></li><li><p>方便的过渡效果</p></li><li><p>直观的页面组织方式</p></li><li><p>命令式地跳转</p></li></ul><p>关于最后一点，我相信应该有很多人都深有体会。虽然Vue的设计哲学是声明式地编写界面，但是某些情况下，命令式地调用函数往往比修改某个响应式变量的值要舒服的多。例如当我们要在某个嵌套得很深的子组件内切换页面时，使用v-if需要我们把事件穿过层层组件上报给父组件，或者把父组件的方法provide下去，这样往往会增加组件间的耦合性，更好的做法是使用全局store或者Vue3的hooks把currentPage拆分到独立的文件中，于是在考虑了许多边界条件之后，我们兴奋地发现，我们重新实现了router。</p><h1 level=\"1\">异步，异步，不择手段地异步</h1><p>Peek的核心是基于peerjs的数据通讯系统，而peerjs的api是基于监听器的，如果直接基于peerjs编写传输功能，会消耗大量的时间在检查监听器设置是否正确，以及判断各种边界条件上，并且整个peerjs实例会在各个组件中被用来用去，不利于后续bug排查，也很容易导致冲突，因此对peerjs进行封装很有必要。</p><p>在封装的设计上，我把整个数据通讯模块分为了两个部分，第一个部分为通讯主体，它负责处理通讯握手阶段，然后在握手成功后将peerjs实例和连接实例传递给插件使用；第二个部分为插件，它们会在握手成功后被初始化，并根据自身用途调用peerjs相关的api，例如发生消息，进行通话等。</p><p>先来看握手阶段，由于peerjs的connect方法是直接建立连接，并没有用户确认的过程，因此我们需要在此之上模拟一层用户手动确认的过程，即需要被连接的用户向发起者发送确认信息，才能进入真正的聊天阶段。因此，这里需要用到许多监听器，但是这样会导致组件产生太多业务无关的代码，我希望组件能专注界面展现，需要一个便捷的接口来实现这一点：</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-comment\" class=\"hljs-comment\">// 伪代码展示Peek的使用</span>\n<span class=\"hljs-comment\" class=\"hljs-comment\">// 主动连接</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">connect</span> = <span class=\"hljs-keyword\" class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">id</span>:<span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\" class=\"hljs-attr\">info</span>:<span class=\"hljs-built_in\" class=\"hljs-built_in\">any</span></span>) =&gt; {\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> accepted = peek.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">connect</span>(id, info);\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">try</span>{\n\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">await</span> accepted;\n\t\t<span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">console</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">log</span>(<span class=\"hljs-string\" class=\"hljs-string\">&quot;connect success&quot;</span>)\n\t}<span class=\"hljs-keyword\" class=\"hljs-keyword\">catch</span>{\n\t\t<span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">console</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">log</span>(<span class=\"hljs-string\" class=\"hljs-string\">&quot;connect rejected&quot;</span>)\n\t}\n}\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">// 被动连接</span>\npeek.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">onBeRequest</span>( <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">async</span> (<span class=\"hljs-attr\" class=\"hljs-attr\">info</span>:<span class=\"hljs-built_in\" class=\"hljs-built_in\">any</span>, accept, reject) =&gt; {\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">try</span>{\n\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">await</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">confirm</span>(<span class=\"hljs-string\" class=\"hljs-string\">`<span class=\"hljs-subst\" class=\"hljs-subst\">${info.name}</span> wants to connect with you, confirm?`</span>)\n\t\t<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">accept</span>()\n\t}<span class=\"hljs-keyword\" class=\"hljs-keyword\">catch</span>{\n\t\t<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">reject</span>()\n\t}\n})\n</code></pre></div></div><p>我们把整个握手过程抽象成一次异步调用过程，极大地降低了理解成本，也减少了在组件中插入的非业务代码，让组件专注于UI处理。</p><p>不过，最终功能的完成还是少不了监听器的，脏活还是要交给peek内部来实现</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-comment\" class=\"hljs-comment\">// Peek内部实现伪代码</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createPeek</span>=(<span class=\"hljs-params\" class=\"hljs-params\"></span>)=&gt;{\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> peer=<span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Peer</span>();\n\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">connect</span>=(<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">id</span>:<span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span>, <span class=\"hljs-attr\" class=\"hljs-attr\">info</span>:<span class=\"hljs-built_in\" class=\"hljs-built_in\">any</span></span>)=&gt;{\n\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> connection=peer.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">connect</span>(id, {<span class=\"hljs-attr\" class=\"hljs-attr\">metadata</span>:info})\n\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">new</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Promise</span>(<span class=\"hljs-function\" class=\"hljs-function\">(<span class=\"hljs-params\" class=\"hljs-params\">res, rej</span>)=&gt;</span>{\n\t\t\t<span class=\"hljs-comment\" class=\"hljs-comment\">// 监听收到的信息</span>\n\t\t\tconnection.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">once</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;data&apos;</span>, <span class=\"hljs-function\" class=\"hljs-function\">(<span class=\"hljs-params\" class=\"hljs-params\">data</span>)=&gt;</span>{\n\t\t\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span>(data===<span class=\"hljs-string\" class=\"hljs-string\">&apos;accept&apos;</span>){\n\t\t\t\t\t<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">res</span>()\n\t\t\t\t}<span class=\"hljs-keyword\" class=\"hljs-keyword\">else</span>{\n\t\t\t\t\t<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">rej</span>()\n\t\t\t\t\tconnection.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">close</span>()\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">onBeRequest</span>=(<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">fn</span>:(info:<span class=\"hljs-built_in\" class=\"hljs-built_in\">any</span>, accept:<span class=\"hljs-built_in\" class=\"hljs-built_in\">Function</span> ,reject:<span class=\"hljs-built_in\" class=\"hljs-built_in\">Function</span>)=&gt;<span class=\"hljs-built_in\" class=\"hljs-built_in\">void</span></span>)=&gt;{\n\t\tpeer.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">on</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;connection&apos;</span>, <span class=\"hljs-function\" class=\"hljs-function\">(<span class=\"hljs-params\" class=\"hljs-params\">connection</span>)=&gt;</span>{\n\t\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> info = connection.<span class=\"hljs-property\" class=\"hljs-property\">metadata</span>\n\t\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">accpet</span>=(<span class=\"hljs-params\" class=\"hljs-params\"></span>)=&gt;{\n\t\t\t\t<span class=\"hljs-comment\" class=\"hljs-comment\">// 发送确认信息</span>\n\t\t\t\tconnection.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">send</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;accept&apos;</span>)\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">reject</span>=(<span class=\"hljs-params\" class=\"hljs-params\"></span>)=&gt;{\n\t\t\t\t<span class=\"hljs-comment\" class=\"hljs-comment\">// 发送拒绝信息并关闭连接</span>\n\t\t\t\tconnection.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">send</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;reject&apos;</span>)\n\t\t\t\tconnection.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">close</span>()\n\t\t\t}\n\t\t\t<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">fn</span>(info, accept, reject)\n\t\t})\n\t}\n\t<span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> {\n\t\tconnect,\n\t\tonBeRequest,\n\t}\n}\n</code></pre></div></div><p>这里省去了许多peerjs的api用法展示，主要专注于整套握手逻辑的实现，使用promise搭配监听器，将原本的监听过程变为异步的等待过程，降低了代码复杂度，并易于理解。</p><p>这样的思想也贯穿在后续插件的设计中，比如Message插件，需要实现消息发送成功的回调，也同样用到了类似的方法。Call插件的异步则较为复杂，因为音视频通话还存在一个中途取消的过程，所以用到的监听器和判断条件也更多，再加上peerjs本身还存在一些未解决的bug，导致Call插件的实现逻辑更为复杂，不过依然保持了业务分离原则，让组件保持尽可能地纯粹。</p><script type=\"module\">const injectHtml = (root, html) => {\n  const iframe = document.createElement(\"iframe\");\n  const htmlContent = `<html><head></head><body>${html}</body></html>`;\n  iframe.style.width = \"100%\";\n  iframe.style.height = \"100%\";\n  iframe.onload = () => {\n    const doc = iframe.contentDocument || iframe.contentWindow?.document;\n    if (!doc) {\n      return;\n    }\n    doc.open();\n    doc.write(htmlContent);\n    doc.close();\n  };\n  root.replaceChildren(iframe);\n}\n  document.querySelectorAll('.playground')?.forEach(el=>{\n    const html = el.getAttribute('data-html');\n    if (html) {\n      injectHtml(el,html);\n    }\n    const indicator = document.createElement(\"div\");\n    indicator.className = \"indicator\";\n    const showCode = document.createElement(\"div\");\n    showCode.className = \"show-code\";\n    showCode.innerText = \"code\";\n    showCode.onclick = () => {\n      el.parentElement.classList.remove(\"preview-only\");\n    };\n    const showPreview = document.createElement(\"div\");\n    showPreview.className = \"show-preview\";\n    showPreview.innerText = \"preview\";\n    showPreview.onclick = () => {\n      el.parentElement.classList.add(\"preview-only\");\n    };\n    indicator.appendChild(showCode);\n    indicator.appendChild(showPreview);\n    el.parentElement.appendChild(indicator);\n    if (window.screen.width < 768) {\n      showPreview.click();\n    }\n  });</script>","id":"什么是Peek点对点快传","path":"/posts/什么是Peek点对点快传.json"}