{"content":"{\"__ud_title\":\"使用自定义的 VitePress 构建自己的博客\",\"__ud_tags\":[\"Vitepress\"],\"__ud_update_time\":1731919010789,\"__ud_create_time\":1731893872976,\"__ud_draft\":false,\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":2},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"使用自定义的 VitePress 构建自己的博客\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"什么是 VitePress\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"VitePress 的原理是利用 Vue 的 SSR 特性，服务端先把包含 Markdown 文本内容的 Vue 组件渲染成多个静态 HTML 文件，再配合内置的简易路由系统生成一个博客站点，这其实与 VuePress 的原理如出一辙，不过 VitePress 舍弃了许多臃肿的功能，只保留最简单的渲染系统，并且重新实现了一个简易的 router，保持了轻量性，同时也因为使用 Vite 提高了开发时的速度，对于拥有大量文档的项目十分友好。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"开始使用\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"按照 VitePress 官方网站的\"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://vitepress.vuejs.org/guide/getting-started.html\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer nofollow\",\"class\":null}}],\"text\":\"教程\"},{\"type\":\"text\",\"text\":\"，一个标准的 VitePress 项目文件结构如下：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"sh\"},\"content\":[{\"type\":\"text\",\"text\":\"├─ docs\\n│  ├─ .vitepress\\n│  │  └─ config.js\\n│  └─ index.md\\n└─ package.json\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"从这里就可以看出，\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\".vitepress\"},{\"type\":\"text\",\"text\":\"这个文件夹包含了 VitePress 所需的配置结构，并且可以指定特定文件夹为主目录。出于个人习惯，我比较喜欢把文档与配置分开，变成如下目录结构\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"sh\"},\"content\":[{\"type\":\"text\",\"text\":\"├─ docs\\n│    └─ other-documents.md\\n├─ .vitepress\\n│    └─ config.js\\n├─ index.md\\n└─ package.json\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"index.md\"},{\"type\":\"text\",\"text\":\" 作为博客的入口文件，一般我们不会使用它的具体内容，简单设置 frontmatter 即可。 VitePress 会自动使用文档的路径作为访问的 URL，例如上面的\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"other-documents.md\"},{\"type\":\"text\",\"text\":\"对应的页面就是\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"localhost:3000/#/docs/other-documents.html\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"主题\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"VitePress 的默认主题作为普通文档项目已经很不错了，不过作为博客还是有点不够个性化，因此也提供了主题功能。新建文件夹\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\".VitePress/theme\"},{\"type\":\"text\",\"text\":\"，结构如下\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"sh\"},\"content\":[{\"type\":\"text\",\"text\":\"├─ docs\\n│    └─ other-documents.md\\n├─ .vitepress\\n│    └─ config.js\\n│    └─ theme\\n│        └─ index.js\\n│        └─ Layout.vue\\n│        └─ NotFound.vue\\n├─ index.md\\n└─ package.json\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"一般来说，VitePress 的主题文件需要至少导出\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"Layout\"},{\"type\":\"text\",\"text\":\"和\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"NotFound\"},{\"type\":\"text\",\"text\":\"两个组件，前者即渲染 HTML 所用的模版组件，后者则为 404 页面。 一个简单的 Layout 页面如下\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"vue\"},\"content\":[{\"type\":\"text\",\"text\":\"<script setup lang=\\\"ts\\\">\\nimport { useData } from \\\"vitepress\\\";\\nconst { site, page } = useData<CustomThemeConfig>();\\n</script>\\n<template>\\n  <div>Hello VitePress</div>\\n  <Content />\\n</template>\\n<style lang=\\\"scss\\\"></style>\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"<Content />\"},{\"type\":\"text\",\"text\":\"是 VitePress 的内置组件，用于渲染默认的 markdown 文件；\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"useData\"},{\"type\":\"text\",\"text\":\"是 VitePress 提供的内置 hoook，其中包含了每个页面的标题、描述、内容等数据，我们就可以通过这些数据来渲染个性化的博客页面，就像写一个普通的 Vue 组件一样。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"SSR 相关问题\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"因为 VitePress 使用的是服务端渲染，所以一些客户端的组件在渲染时可能会报错\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"Hydration is completed but contains mismatches\"},{\"type\":\"text\",\"text\":\"，例如使用了自定义指令或者使用了\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"onMounted\"},{\"type\":\"text\",\"text\":\"等服务端不支持的生命周期函数，对于这些特殊组件，我们可以使用 VitePress 内置的组件\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"<ClientOnly></ClientOnly>\"},{\"type\":\"text\",\"text\":\"来包裹特定组件，告诉 VitePress 只在客户端渲染这些组件。如果仍然报错，可以优化自定义指令的实现逻辑，增加对客户端环境的判断然后再条件执行.\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"const isClient = typeof window !== \\\"undefined\\\";\\nif (isClient) {\\n  // do something\\n}\\n\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"额外的配置数据\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"对于需要展示文章列表的博客，VitePress 并没有提供一个方便的 API 来获取所有文章的数据，因此我们需要手动读取文章数据，得益于 Node 强大的生态，这件事情做起来很简单。\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"// utils.ts\\nimport { readFile } from \\\"fs\\\";\\n// gray-matter 用于读取markdown文件的frontmatter\\nimport matter from \\\"gray-matter\\\";\\n\\nexport default async function getArticles() {\\n  // 读取文件夹中的markdown文件并解析\\n  // await reading...\\n  return [];\\n}\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"hardBreak\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"// config.ts\\nimport { defineConfigWithTheme } from \\\"vitepress\\\";\\n// getArticles 函数中实现读取文章列表的功能\\nimport getArticles from \\\"./utils\\\";\\n\\n// config.ts 可以导出异步函数\\nexport default async () =>\\ndefineConfigWithTheme<CustomThemeConfig}>({\\n  themeConfig: {\\n    articles: await getArticles(),\\n  },\\n});\\n\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"hardBreak\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"vue\"},\"content\":[{\"type\":\"text\",\"text\":\"<script setup lang=\\\"ts\\\">\\nimport { useData } from \\\"vitepress\\\";\\nconst data = useData<CustomThemeConfig>();\\n// 使用useData获得themeConfig中传入的articles数据\\nconst articles = computed(() => site.value.themeConfig.articles);\\n</script>\\n<template>\\n  <div class=\\\"list\\\">\\n    <div v-for=\\\"(article, index) in articles\\\" class=\\\"item\\\">\\n      {{ article.title }}\\n    </div>\\n  </div>\\n</template>\\n<style></style>\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"同样的方法可以获取到配置文件传递的其他数据。要注意只能从 VitePress 提供的数据中获取数据，因为在渲染完成后无法访问到 Node 环境。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"Tips\"}]},{\"type\":\"orderedList\",\"attrs\":{\"start\":1},\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"一些情况下，使用\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"v-if\"},{\"type\":\"text\",\"text\":\"指令也会导致 SSR Hydration 出现报错，但不会影响 HTML 到正常渲染，可以使用\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"v-show\"},{\"type\":\"text\",\"text\":\"代替。\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Markdown 文件开头可以设置 fromtmatter，可以包含文章标题、简述、题图等信息，方便自定义渲染，例如\"}]}]}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"markdown\"},\"content\":[{\"type\":\"text\",\"text\":\"---\\ndate: 2021-01-06\\ntitle: 首页\\ndescribe: 首页\\nhome: true\\n---\\n\"}]},{\"type\":\"orderedList\",\"attrs\":{\"start\":3},\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"可以直接引入 VitePress 内置的样式和主题文件，然后在原始主题基础上进行修改，例如\"}]}]}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"// theme/index.ts\\nimport defaultTheme from \\\"vitepress/theme\\\";\\nimport NotFound from \\\"./NotFound.vue\\\";\\nimport Layout from \\\"./Layout.vue\\\";\\n\\nexport default {\\n  ...defaultTheme,\\n  NotFound,\\n  Layout,\\n};\\n\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"最后\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"VitePress 还支持许多特性，例如自定义 vite 配置、自定义 markdown 渲染器、markdown 文件内引入 vue 组件(例如： )等等，这些都可以在 VitePress 的\"},{\"type\":\"text\",\"marks\":[{\"type\":\"link\",\"attrs\":{\"href\":\"https://vitepress.vuejs.org/\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer nofollow\",\"class\":null}}],\"text\":\"官方文档\"},{\"type\":\"text\",\"text\":\"内看到，默默等待 VitePress 正式版发布吧。\"}]}]}","title":"使用自定义的 VitePress 构建自己的博客","tags":["Vitepress"],"updateTime":1731919010789,"createTime":1731893872976,"draft":false,"intro":"VitePress 的原理是利用 Vue 的 SSR 特性，服务端先把包含 Markdown 文本内容的 Vue 组件渲染成多个静态 HTML 文件，再配合内置的简易路由系统生成一个博客站点，这其实与 VuePress 的原理如出一辙，不过 VitePress 舍弃了许多臃肿的功能，只保留最简单的渲染系统，并且重新实现了一个简易的 router，保持了轻量性，同时也因为使用 Vite 提高了开发时的速度，对于拥有大量文档的项目十分友好。","html":"<h2 level=\"2\" id=\"使用自定义的-VitePress-构建自己的博客\"><strong>使用自定义的 VitePress 构建自己的博客</strong></h2><h3 level=\"3\" id=\"什么是-VitePress\"><strong>什么是 VitePress</strong></h3><p>VitePress 的原理是利用 Vue 的 SSR 特性，服务端先把包含 Markdown 文本内容的 Vue 组件渲染成多个静态 HTML 文件，再配合内置的简易路由系统生成一个博客站点，这其实与 VuePress 的原理如出一辙，不过 VitePress 舍弃了许多臃肿的功能，只保留最简单的渲染系统，并且重新实现了一个简易的 router，保持了轻量性，同时也因为使用 Vite 提高了开发时的速度，对于拥有大量文档的项目十分友好。</p><h3 level=\"3\" id=\"开始使用\"><strong>开始使用</strong></h3><p>按照 VitePress 官方网站的<a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://vitepress.vuejs.org/guide/getting-started.html\">教程</a>，一个标准的 VitePress 项目文件结构如下：</p><div class=\"llt-code readonly\"><div class=\"language\">sh</div><div class=\"wrapper\"><pre><code class=\"language-sh\">├─ docs\n│  ├─ .vitepress\n│  │  └─ config.js\n│  └─ index.md\n└─ package.json\n</code></pre></div></div><p>从这里就可以看出，<code>.vitepress</code>这个文件夹包含了 VitePress 所需的配置结构，并且可以指定特定文件夹为主目录。出于个人习惯，我比较喜欢把文档与配置分开，变成如下目录结构</p><div class=\"llt-code readonly\"><div class=\"language\">sh</div><div class=\"wrapper\"><pre><code class=\"language-sh\">├─ docs\n│    └─ other-documents.md\n├─ .vitepress\n│    └─ config.js\n├─ index.md\n└─ package.json\n</code></pre></div></div><p><code>index.md</code> 作为博客的入口文件，一般我们不会使用它的具体内容，简单设置 frontmatter 即可。 VitePress 会自动使用文档的路径作为访问的 URL，例如上面的<code>other-documents.md</code>对应的页面就是<code>localhost:3000/#/docs/other-documents.html</code></p><h3 level=\"3\" id=\"主题\"><strong>主题</strong></h3><p>VitePress 的默认主题作为普通文档项目已经很不错了，不过作为博客还是有点不够个性化，因此也提供了主题功能。新建文件夹<code>.VitePress/theme</code>，结构如下</p><div class=\"llt-code readonly\"><div class=\"language\">sh</div><div class=\"wrapper\"><pre><code class=\"language-sh\">├─ docs\n│    └─ other-documents.md\n├─ .vitepress\n│    └─ config.js\n│    └─ theme\n│        └─ index.js\n│        └─ Layout.vue\n│        └─ NotFound.vue\n├─ index.md\n└─ package.json\n</code></pre></div></div><p>一般来说，VitePress 的主题文件需要至少导出<code>Layout</code>和<code>NotFound</code>两个组件，前者即渲染 HTML 所用的模版组件，后者则为 404 页面。 一个简单的 Layout 页面如下</p><div class=\"llt-code readonly\"><div class=\"language\">vue</div><div class=\"wrapper\"><pre><code class=\"language-vue\"><span class=\"xml\" class=\"xml\"><span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">script</span> <span class=\"hljs-attr\" class=\"hljs-attr\">setup</span> <span class=\"hljs-attr\" class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;ts&quot;</span>&gt;</span><span class=\"javascript\" class=\"javascript\">\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> { useData } <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;vitepress&quot;</span>;\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> { site, page } = useData&lt;<span class=\"hljs-title,class_\" class=\"hljs-title,class_\">CustomThemeConfig</span>&gt;();\n</span><span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">div</span>&gt;</span>Hello VitePress<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">Content</span> /&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">style</span> <span class=\"hljs-attr\" class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;scss&quot;</span>&gt;</span></span><span class=\"scss\" class=\"scss\">&lt;/style&gt;\n</span></code></pre></div></div><p><code>&lt;Content /&gt;</code>是 VitePress 的内置组件，用于渲染默认的 markdown 文件；<code>useData</code>是 VitePress 提供的内置 hoook，其中包含了每个页面的标题、描述、内容等数据，我们就可以通过这些数据来渲染个性化的博客页面，就像写一个普通的 Vue 组件一样。</p><h3 level=\"3\" id=\"SSR-相关问题\"><strong>SSR 相关问题</strong></h3><p>因为 VitePress 使用的是服务端渲染，所以一些客户端的组件在渲染时可能会报错<code>Hydration is completed but contains mismatches</code>，例如使用了自定义指令或者使用了<code>onMounted</code>等服务端不支持的生命周期函数，对于这些特殊组件，我们可以使用 VitePress 内置的组件<code>&lt;ClientOnly&gt;&lt;/ClientOnly&gt;</code>来包裹特定组件，告诉 VitePress 只在客户端渲染这些组件。如果仍然报错，可以优化自定义指令的实现逻辑，增加对客户端环境的判断然后再条件执行.</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> isClient = <span class=\"hljs-keyword\" class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">window</span> !== <span class=\"hljs-string\" class=\"hljs-string\">&quot;undefined&quot;</span>;\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span> (isClient) {\n  <span class=\"hljs-comment\" class=\"hljs-comment\">// do something</span>\n}\n</code></pre></div></div><h3 level=\"3\" id=\"额外的配置数据\"><strong>额外的配置数据</strong></h3><p>对于需要展示文章列表的博客，VitePress 并没有提供一个方便的 API 来获取所有文章的数据，因此我们需要手动读取文章数据，得益于 Node 强大的生态，这件事情做起来很简单。</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-comment\" class=\"hljs-comment\">// utils.ts</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> { readFile } <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;fs&quot;</span>;\n<span class=\"hljs-comment\" class=\"hljs-comment\">// gray-matter 用于读取markdown文件的frontmatter</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> matter <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;gray-matter&quot;</span>;\n\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">function</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">getArticles</span>(<span class=\"hljs-params\" class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\" class=\"hljs-comment\">// 读取文件夹中的markdown文件并解析</span>\n  <span class=\"hljs-comment\" class=\"hljs-comment\">// await reading...</span>\n  <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> [];\n}\n</code></pre></div></div><p><br></p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-comment\" class=\"hljs-comment\">// config.ts</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> { defineConfigWithTheme } <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;vitepress&quot;</span>;\n<span class=\"hljs-comment\" class=\"hljs-comment\">// getArticles 函数中实现读取文章列表的功能</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> getArticles <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;./utils&quot;</span>;\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">// config.ts 可以导出异步函数</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">default</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">async</span> () =&gt;\ndefineConfigWithTheme&lt;<span class=\"hljs-title,class_\" class=\"hljs-title,class_\">CustomThemeConfig</span>}&gt;({\n  <span class=\"hljs-attr\" class=\"hljs-attr\">themeConfig</span>: {\n    <span class=\"hljs-attr\" class=\"hljs-attr\">articles</span>: <span class=\"hljs-keyword\" class=\"hljs-keyword\">await</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">getArticles</span>(),\n  },\n});\n\n</code></pre></div></div><p><br></p><div class=\"llt-code readonly\"><div class=\"language\">vue</div><div class=\"wrapper\"><pre><code class=\"language-vue\"><span class=\"xml\" class=\"xml\"><span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">script</span> <span class=\"hljs-attr\" class=\"hljs-attr\">setup</span> <span class=\"hljs-attr\" class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;ts&quot;</span>&gt;</span><span class=\"javascript\" class=\"javascript\">\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> { useData } <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;vitepress&quot;</span>;\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> data = useData&lt;<span class=\"hljs-title,class_\" class=\"hljs-title,class_\">CustomThemeConfig</span>&gt;();\n<span class=\"hljs-comment\" class=\"hljs-comment\">// 使用useData获得themeConfig中传入的articles数据</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> articles = <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">computed</span>(<span class=\"hljs-function\" class=\"hljs-function\">() =&gt;</span> site.<span class=\"hljs-property\" class=\"hljs-property\">value</span>.<span class=\"hljs-property\" class=\"hljs-property\">themeConfig</span>.<span class=\"hljs-property\" class=\"hljs-property\">articles</span>);\n</span><span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">div</span> <span class=\"hljs-attr\" class=\"hljs-attr\">class</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;list&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">div</span> <span class=\"hljs-attr\" class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;(article, index) in articles&quot;</span> <span class=\"hljs-attr\" class=\"hljs-attr\">class</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>\n      {{ article.title }}\n    <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">style</span>&gt;</span></span><span class=\"css\" class=\"css\">&lt;/style&gt;\n</span></code></pre></div></div><p>同样的方法可以获取到配置文件传递的其他数据。要注意只能从 VitePress 提供的数据中获取数据，因为在渲染完成后无法访问到 Node 环境。</p><h2 level=\"2\" id=\"Tips\"><strong>Tips</strong></h2><ol><li><p>一些情况下，使用<code>v-if</code>指令也会导致 SSR Hydration 出现报错，但不会影响 HTML 到正常渲染，可以使用<code>v-show</code>代替。</p></li><li><p>Markdown 文件开头可以设置 fromtmatter，可以包含文章标题、简述、题图等信息，方便自定义渲染，例如</p></li></ol><div class=\"llt-code readonly\"><div class=\"language\">markdown</div><div class=\"wrapper\"><pre><code class=\"language-markdown\">---\ndate: 2021-01-06\ntitle: 首页\ndescribe: 首页\n<span class=\"hljs-section\" class=\"hljs-section\">home: true\n---</span>\n</code></pre></div></div><ol start=\"3\"><li><p>可以直接引入 VitePress 内置的样式和主题文件，然后在原始主题基础上进行修改，例如</p></li></ol><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-comment\" class=\"hljs-comment\">// theme/index.ts</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> defaultTheme <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;vitepress/theme&quot;</span>;\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">NotFound</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;./NotFound.vue&quot;</span>;\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Layout</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;./Layout.vue&quot;</span>;\n\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\" class=\"hljs-keyword\">default</span> {\n  ...defaultTheme,\n  <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">NotFound</span>,\n  <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Layout</span>,\n};\n</code></pre></div></div><h2 level=\"2\" id=\"最后\"><strong>最后</strong></h2><p>VitePress 还支持许多特性，例如自定义 vite 配置、自定义 markdown 渲染器、markdown 文件内引入 vue 组件(例如： )等等，这些都可以在 VitePress 的<a target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://vitepress.vuejs.org/\">官方文档</a>内看到，默默等待 VitePress 正式版发布吧。</p><script type=\"module\">const injectHtml = (root, html) => {\n  const iframe = document.createElement(\"iframe\");\n  const htmlContent = `<html><head></head><body>${html}</body></html>`;\n  iframe.style.width = \"100%\";\n  iframe.style.height = \"100%\";\n  iframe.onload = () => {\n    const doc = iframe.contentDocument || iframe.contentWindow?.document;\n    if (!doc) {\n      return;\n    }\n    doc.open();\n    doc.write(htmlContent);\n    doc.close();\n  };\n  root.replaceChildren(iframe);\n}\n  document.querySelectorAll('.playground')?.forEach(el=>{\n    const html = el.getAttribute('data-html');\n    if (html) {\n      injectHtml(el,html);\n    }\n    const indicator = document.createElement(\"div\");\n    indicator.className = \"indicator\";\n    const showCode = document.createElement(\"div\");\n    showCode.className = \"show-code\";\n    showCode.innerText = \"code\";\n    showCode.onclick = () => {\n      el.parentElement.classList.remove(\"preview-only\");\n    };\n    const showPreview = document.createElement(\"div\");\n    showPreview.className = \"show-preview\";\n    showPreview.innerText = \"preview\";\n    showPreview.onclick = () => {\n      el.parentElement.classList.add(\"preview-only\");\n    };\n    indicator.appendChild(showCode);\n    indicator.appendChild(showPreview);\n    el.parentElement.appendChild(indicator);\n    if (window.screen.width < 768) {\n      showPreview.click();\n    }\n  });</script>","id":"VitePress","path":"/posts/VitePress.json"}