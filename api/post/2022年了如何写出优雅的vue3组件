{"content":"{\"__ud_title\":\"2022年了，如何写出优雅的vue3组件\",\"__ud_tags\":[\"Vue3\"],\"__ud_update_time\":1731918936800,\"__ud_create_time\":1731911415454,\"__ud_draft\":false,\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":2},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"2022年了，如何写出优雅的vue3组件\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":1},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"拥抱Setup\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在我看来，vue3和vue2最大的区别就是响应式的思考方式的改变，在vue2中，响应式是渲染框架的一部分，你没办法单独地创建一个响应式状态然后复用它，只能用mixin把状态像配置文件那样隔离出来，再用在其他组件当中，响应式也只在组件中生效，这使得一套业务逻辑很难在vue中复用。如果你想要构建组件库，在vue2中最好的方式是构建一个大而全的组件，然后提供数量繁多的props给开发者自定义，而不是提供细粒度的单个组件让开发者自己组装，因为组装需要的逻辑一旦涉及到组件状态就会无法抽离，导致许多重复又无意义的封装。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"而在vue3中，响应式与组件渲染被彻底分离，并且与React hooks完全不同，响应式式真正的全局响应，而非只有在React或者Vue组件内使用才表现出响应性，例如computed和watch完全可以用在一个没有任何vue文件的项目中，而非依赖于组件框架。这也意味着在vue3中，渲染引擎成为了响应式的应用，Vue3的重新渲染是通过在响应式提供的监听变化的能力实现的，甚至我们可以自己写一个简单的渲染函数，例如\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"cons render = (state:Ref<string>)=>{\\n    const html=`<div>${state.value}</div>`\\n    watchEffect(()=>{\\n        document.body.innerHTML=html\\n    })\\n}\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"所以在vue3中，我更愿意去使用细粒度更小的组件，任何通过各式各样的useXXX hooks函数把它们组装起来，对响应式变量进行操作，而不是沿用vue2时代臃肿复杂的方式，对着this不停地放入和调用不知道是谁放进去的属性和函数。所以在实际体验方面，vue2和vue3项目看起最大的区别，除了每个vue文件都使用了setup模式来编写，每个vue文件的行数都少了许多之外，就是那个新增的hooks文件夹，里面放着从原本vue文件里抽离出来的各式各样封装好的逻辑，只需要维护这个hooks文件夹，就能维护好项目核心的业务逻辑。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"为了达到这样的目的，setup模式，或者说composition api是必需的，如果在vue3中继续使用options api，那你也将与这些唾手可得的优势失之交臂。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"如无必要，勿增指令\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"当我们不可避免地需要去手动操作dom的时候，vue2时的第一反应就是使用自定义指令，但在我看来，这个功能在有了composition api之后已经可以被完全代替了，在有了\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"ref\"},{\"type\":\"text\",\"text\":\" \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"onMounted\"},{\"type\":\"text\",\"text\":\"这些专门用来处理生命周期的函数和钩子之后，我们不再需要写自定义指令也能把dom操作拆分出来，事实上\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"vueuse\"},{\"type\":\"text\",\"text\":\"已经有例如\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"useClickOutside\"},{\"type\":\"text\",\"text\":\" \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"onLongpress\"},{\"type\":\"text\",\"text\":\"等和指令功能完全一致的替换hokk了，并且在类型支持方面比指令更为友好\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"实例 - MessageBox组件\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在vue2时代，我最喜欢element-ui组件库的一个功能，就是ElMessageBox，因为只需要在代码中简单地引入，然后调用对应的\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"this.$alert\"},{\"type\":\"text\",\"text\":\"或者\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"this.$confirm\"},{\"type\":\"text\",\"text\":\"等方法，就可以简单快速地在页面上弹出一条提示，不需要引入其他的组件，也不需要写一堆data用来绑定组件参数，然后把乱七八糟的visible啊title啊之类的传进去，甚至还可以设置基于Promise的回调，整个过程就像调用浏览器的原生api\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"confirm\"},{\"type\":\"text\",\"text\":\"或者\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"alert\"},{\"type\":\"text\",\"text\":\"一样简单，于是在我编写自己的第一个组件库的时候，我就想把这种方法用到自己的项目中，于是我去了解了相关的源码，element是这样实现的\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"javascript\"},\"content\":[{\"type\":\"text\",\"text\":\"// todo\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"element-ui巧妙地使用了Vue2提供的plugin接口，通过设置全局属性在代码中注入显示message的方法，而方便地提供了弹出消息提示的功能。尽管用起来的很方便，但是背后的实现却不怎么优雅，它脱离了Vue自身的组件渲染机制，通过手动渲染vnode并挂载到body的方式来创建MessageBox的DOM，尽管完美地实现了功能，但还是存在了许多限制，例如无法方便地自定义message的样式，如果想要展示复杂的消息，只能通过传入html字符vnode来渲染自定义内容，传入HTML时不仅要考虑XSS攻击，还要手写一堆HTML模板，至于传入vnode，麻烦程度比起HTML只多不少，那还不如自己写一遍Dialog组件来的快了；同样也无法享受到Vue自带的css scope功能，如果只想改变当前组件内展示的Message样式，就只能在调用方法时传入customClass参数，然后在全局作用的css里小心翼翼地编写样式。在交互简单的模板类项目中，这样的方式无伤大雅，但一旦涉及到了复杂的交互逻辑，就不可避免地要去重新封装一遍。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在vue2时代，这样的方式可以说是带着镣铐跳舞，因为所有的响应式状态传递必须依托于vue的上下文，让我们无法脱离组件去编写单纯的业务逻辑。但是到了vue3时代的element plus，它的MessageBox还是基于相同的逻辑，为了保证迁移的一致性，即使vue3提供了vue/reactivity能力使得组件外编写响应状态成为可能，但是依旧没有解决上面存在的问题。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"那么有方法可以鱼和熊掌兼得吗？得益于vue/reactivity，这个答案是肯定的\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"从送我们的需求触发，我们希望这个完美的MessageBox组件应该是这么用的\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"vue\"},\"content\":[{\"type\":\"text\",\"text\":\"<template>\\n    <other-components />\\n    <perfect-message-box :controller=\\\"controller\\\" >\\n        <custom-component />\\n    </perfect-message-box>\\n</template>\\n<script lang=\\\"ts\\\" setup>\\nimport { useMessageBox, PerfectMessageBox } from \\\"perfect-message-box\\\"\\nconst { confirm, controller } = useMessageBox();\\n\\nconst toDoSomething = async ()=>{\\n    await confirm('Are you sure?');\\n    doSomthing();\\n}\\n</script>\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"**注意所有的vue3代码都是使用setup模式来写的，因为我实在无法理解有了setup为什么还要去写options\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"通过这种方式，我们可以做到了： 1，支持以slots方式传入自定义内容，契合vue的使用方式。 2，按需引入，如果某个懒加载的路由完全没有使用到MessageBox，那么在加载页面的时候就完全不会包括相关的代码。 3，依旧支持Promise调用，函数式的使用方式令人精神愉悦（划掉）。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"这样的方式看起来十分符合我们的需求，那么我们如何才能做到呢？ conroller的实现是重点，它连接了confirm函数和组件的状态，使得调用confirm函数时传入的参数能够被渲染到组件之中，我们可以先从基础的MessageBox组件出发，看看controller需要提供哪些能力，一个简单的MessageBox demo如下：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"vue\"},\"content\":[{\"type\":\"text\",\"text\":\"<template>\\n    <teleport v-if=\\\"visible\\\" :to=\\\"body\\\">\\n        <div class=\\\"message-box\\\">\\n            <slot>\\n                <div>{{title}}</div>\\n            </slot>\\n            <button @click=\\\"()=>{$emit('update:visible',false);$emit('confirm')}\\\">confirm</button>\\n            <button @click=\\\"()=>{$emit('update:visible',false);$emit('cancel')}\\\">cancel</button>\\n        </div>\\n    </teleport>\\n</template>\\n<script lang=\\\"ts\\\" setup>\\ndefineProps<{\\n    visible: boolean;\\n    title: string;\\n}>()\\n\\ndefineEmit<{\\n    (name:\\\"update:visible\\\", value: boolean):void;\\n    (name:\\\"confirm\\\"):void;\\n    (name:\\\"cancel\\\"):void;\\n}>()\\n</script>\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"可以看出，在这里MessageBox是靠Vue的事件来传递用户是否点击了确认或者取消，同时根据父组件传入的visible值来展示或者隐藏自身，那么controller就需要模仿这种事件机制，因为Vue的事件是无法在组件外使用的，可以写出这样的一个controller：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"typescript\"},\"content\":[{\"type\":\"text\",\"text\":\"const useMessageBox=()=>{\\n    const controller = ref({\\n        visible: false,\\n        title:'',\\n        confirm: ()=>undefined,\\n        cancel: ()=>undefined,\\n    })\\n    const show=(title:string)=>Promise<void>((resolve,reject)=>{\\n        controller.value={\\n            title,\\n            visible:true,\\n            confirm:()=>{\\n                controller.value = { ...controller.value, visible: false };\\n                resolve()\\n            },\\n            cancel:()=>{\\n                controller.value = { ...controller.value, visible: false };\\n                reject()\\n            }\\n        }\\n    })\\n    return {\\n        show, controller\\n    }\\n}\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"同时将MessageBox组件修改成这样：\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"vue\"},\"content\":[{\"type\":\"text\",\"text\":\"<template>\\n    <teleport v-if=\\\"visible\\\" :to=\\\"body\\\">\\n        <div class=\\\"message-box\\\">\\n            <slot>\\n                <div>{{controller.title}}</div>\\n            </slot>\\n            <button @click=\\\"controller.confirm()\\\">confirm</button>\\n            <button @click=\\\"controller.cancel()\\\">cancel</button>\\n        </div>\\n    </teleport>\\n</template>\\n<script lang=\\\"ts\\\" setup>\\ndefineProps<{\\n    controller: Controller\\n}>()\\n</script>\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"通过巧妙地设置和改变controller的值，使得组件可以不通过props来获取参数并传递相应的事件，这是不是像极了Vuex或者其他类似的状态管理工具的思路？不同的是，这里我们没有依靠任何第三方状态管理框架，仅凭vue/reactivity的能力就办到了，这也侧面说明某种意义上全局的状态管理能力是可以被vue/reactivity取代的。而在这个实例中，我们简单地通过响应式状态的传递实现了组件props和父组件的解耦，子组件可以不再仅靠声明式的props来渲染内容，父组件也有了更多调用子组件能力的方式，完美实现了原版ElMessageBox的功能，并且与Vue的特性完美结合，不再有奇奇怪怪的hack。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"它还有许多衍生用法，例如导出一个\"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"useGlobalConfirm\"},{\"type\":\"text\",\"text\":\"方法，并在App.vue根组件下插入MessageBox，使得所有组件或者函数在使用MessageBox时共用同一个实例，完美复刻原版ElMessageBox的用法；也可以通过设置controller的更多属性，来支持传入更多配置例如按钮文案、按钮数量等等，还可以将参数本身设置为响应式对象，可以使MessageBox动态展示正在加载的进度等等，整个使用流程和逻辑更符合Vue的思考方式。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"我把这个组件构建思路应用在了Cent中，这样每个组件都只需要关心自己的工作，不再需要处理额外的状态来管理MessageBox弹窗，整个逻辑条理清晰，十分利于维护。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"思考\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"ElMessageBox采用手动构建和挂载DOM的方式还有另外一层因素，就是多层嵌套的MessageBox，例如二次确认或者多次确认，这时单个MessageBox组件就不够用了，那要如何处理这种情况呢？\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"其实解决方法也很简单，我们可以创建一个高阶组件，它专门负责创建重复的组件并自动为组件分配id和层级，把我们的MessageBox包裹起来，就可以了\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"vue\"},\"content\":[{\"type\":\"text\",\"text\":\"<template>\\n    <component v-for=\\\"{component,props,key} in list\\\" :key=\\\"key\\\" :is=\\\"component\\\" v-bind=\\\"props\\\" />\\n</template>\\n<script lang=\\\"ts\\\" setup>\\nimport type { Component } from 'vue';\\n\\ndefineProps<{\\n    list:{\\n        component:Component,\\n        props:any,\\n        key:string\\n    }[]\\n}>()\\n</script>\\n\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"不过同样的，这样也会导致MessageBox失去对自定义slot的支持。大多数情况下，二次确认的弹窗数量不会超过两个因此完全可以将二次确认的MessageBox放在根组件中，而将首次弹窗的MessageBox放在当前的组件，这样也更方便理解逻辑。\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":2},\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"Vue的不足\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"描述Vue和React、Angular之类的框架优劣之争已经有了很多说法，不过我在使用Vue的过程中最大一个痛点就是Vue的单文件写法，单文件在代码组织方面是有优势的，可以方便区分不同的组件，做到许多编译期的优化，但是一个Vue文件只能有一个组件的设计也让我不得不写很多额外的临时组件，例如渲染一个只会在当前组件用到的列表，我实在不想为了单独的列表项目去想一个新名字，为这些临时组件新建一个文件夹，再多写好几遍import、export语句。在react或者其他JSX语言的框架中，我可以把这些临时组件写在一个文件里，随时调用，当然vue也提供了JSX的写法，但是那样就会失去编译器的模板优化，并且vue的JSX与其他框架的语义并不完全相同，一些特殊的用法还得重新学习，显然算不上优雅的解决方法。\"}]}]}","title":"2022年了，如何写出优雅的vue3组件","tags":["Vue3"],"updateTime":1731918936800,"createTime":1731911415454,"draft":false,"intro":"在我看来，vue3和vue2最大的区别就是响应式的思考方式的改变，在vue2中，响应式是渲染框架的一部分，你没办法单独地创建一个响应式状态然后复用它，只能用mixin把状态像配置文件那样隔离出来，再用在其他组件当中，响应式也只在组件中生效，这使得一套业务逻辑很难在vue中复用。如果你想要构建组件库，在vue2中最好的方式是构建一个大而全的组件，然后提供数量繁多的props给开发者自定义，而不是提供细粒度的单个组件让开发者自己组装，因为组装需要的逻辑一旦涉及到组件状态就会无法抽离，导致许多重复又无意义的封装。","html":"<h2 level=\"2\"><strong>2022年了，如何写出优雅的vue3组件</strong></h2><h1 level=\"1\"><strong>拥抱Setup</strong></h1><p>在我看来，vue3和vue2最大的区别就是响应式的思考方式的改变，在vue2中，响应式是渲染框架的一部分，你没办法单独地创建一个响应式状态然后复用它，只能用mixin把状态像配置文件那样隔离出来，再用在其他组件当中，响应式也只在组件中生效，这使得一套业务逻辑很难在vue中复用。如果你想要构建组件库，在vue2中最好的方式是构建一个大而全的组件，然后提供数量繁多的props给开发者自定义，而不是提供细粒度的单个组件让开发者自己组装，因为组装需要的逻辑一旦涉及到组件状态就会无法抽离，导致许多重复又无意义的封装。</p><p>而在vue3中，响应式与组件渲染被彻底分离，并且与React hooks完全不同，响应式式真正的全局响应，而非只有在React或者Vue组件内使用才表现出响应性，例如computed和watch完全可以用在一个没有任何vue文件的项目中，而非依赖于组件框架。这也意味着在vue3中，渲染引擎成为了响应式的应用，Vue3的重新渲染是通过在响应式提供的监听变化的能力实现的，甚至我们可以自己写一个简单的渲染函数，例如</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\">cons render = <span class=\"hljs-function\" class=\"hljs-function\">(<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">state</span>:<span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Ref</span>&lt;<span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span>&gt;</span>)=&gt;</span>{\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> html=<span class=\"hljs-string\" class=\"hljs-string\">`&lt;div&gt;<span class=\"hljs-subst\" class=\"hljs-subst\">${state.value}</span>&lt;/div&gt;`</span>\n    <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">watchEffect</span>(<span class=\"hljs-function\" class=\"hljs-function\">()=&gt;</span>{\n        <span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">document</span>.<span class=\"hljs-property\" class=\"hljs-property\">body</span>.<span class=\"hljs-property\" class=\"hljs-property\">innerHTML</span>=html\n    })\n}\n</code></pre></div></div><p>所以在vue3中，我更愿意去使用细粒度更小的组件，任何通过各式各样的useXXX hooks函数把它们组装起来，对响应式变量进行操作，而不是沿用vue2时代臃肿复杂的方式，对着this不停地放入和调用不知道是谁放进去的属性和函数。所以在实际体验方面，vue2和vue3项目看起最大的区别，除了每个vue文件都使用了setup模式来编写，每个vue文件的行数都少了许多之外，就是那个新增的hooks文件夹，里面放着从原本vue文件里抽离出来的各式各样封装好的逻辑，只需要维护这个hooks文件夹，就能维护好项目核心的业务逻辑。</p><p>为了达到这样的目的，setup模式，或者说composition api是必需的，如果在vue3中继续使用options api，那你也将与这些唾手可得的优势失之交臂。</p><h2 level=\"2\"><strong>如无必要，勿增指令</strong></h2><p>当我们不可避免地需要去手动操作dom的时候，vue2时的第一反应就是使用自定义指令，但在我看来，这个功能在有了composition api之后已经可以被完全代替了，在有了<code>ref</code> <code>onMounted</code>这些专门用来处理生命周期的函数和钩子之后，我们不再需要写自定义指令也能把dom操作拆分出来，事实上<code>vueuse</code>已经有例如<code>useClickOutside</code> <code>onLongpress</code>等和指令功能完全一致的替换hokk了，并且在类型支持方面比指令更为友好</p><h2 level=\"2\"><strong>实例 - MessageBox组件</strong></h2><p>在vue2时代，我最喜欢element-ui组件库的一个功能，就是ElMessageBox，因为只需要在代码中简单地引入，然后调用对应的<code>this.$alert</code>或者<code>this.$confirm</code>等方法，就可以简单快速地在页面上弹出一条提示，不需要引入其他的组件，也不需要写一堆data用来绑定组件参数，然后把乱七八糟的visible啊title啊之类的传进去，甚至还可以设置基于Promise的回调，整个过程就像调用浏览器的原生api<code>confirm</code>或者<code>alert</code>一样简单，于是在我编写自己的第一个组件库的时候，我就想把这种方法用到自己的项目中，于是我去了解了相关的源码，element是这样实现的</p><div class=\"llt-code readonly\"><div class=\"language\">javascript</div><div class=\"wrapper\"><pre><code class=\"language-javascript\"><span class=\"hljs-comment\" class=\"hljs-comment\">// todo</span>\n</code></pre></div></div><p>element-ui巧妙地使用了Vue2提供的plugin接口，通过设置全局属性在代码中注入显示message的方法，而方便地提供了弹出消息提示的功能。尽管用起来的很方便，但是背后的实现却不怎么优雅，它脱离了Vue自身的组件渲染机制，通过手动渲染vnode并挂载到body的方式来创建MessageBox的DOM，尽管完美地实现了功能，但还是存在了许多限制，例如无法方便地自定义message的样式，如果想要展示复杂的消息，只能通过传入html字符vnode来渲染自定义内容，传入HTML时不仅要考虑XSS攻击，还要手写一堆HTML模板，至于传入vnode，麻烦程度比起HTML只多不少，那还不如自己写一遍Dialog组件来的快了；同样也无法享受到Vue自带的css scope功能，如果只想改变当前组件内展示的Message样式，就只能在调用方法时传入customClass参数，然后在全局作用的css里小心翼翼地编写样式。在交互简单的模板类项目中，这样的方式无伤大雅，但一旦涉及到了复杂的交互逻辑，就不可避免地要去重新封装一遍。</p><p>在vue2时代，这样的方式可以说是带着镣铐跳舞，因为所有的响应式状态传递必须依托于vue的上下文，让我们无法脱离组件去编写单纯的业务逻辑。但是到了vue3时代的element plus，它的MessageBox还是基于相同的逻辑，为了保证迁移的一致性，即使vue3提供了vue/reactivity能力使得组件外编写响应状态成为可能，但是依旧没有解决上面存在的问题。</p><p>那么有方法可以鱼和熊掌兼得吗？得益于vue/reactivity，这个答案是肯定的</p><p>从送我们的需求触发，我们希望这个完美的MessageBox组件应该是这么用的</p><div class=\"llt-code readonly\"><div class=\"language\">vue</div><div class=\"wrapper\"><pre><code class=\"language-vue\"><span class=\"xml\" class=\"xml\"><span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">other-components</span> /&gt;</span>\n    <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">perfect-message-box</span> <span class=\"hljs-attr\" class=\"hljs-attr\">:controller</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;controller&quot;</span> &gt;</span>\n        <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">custom-component</span> /&gt;</span>\n    <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">perfect-message-box</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">script</span> <span class=\"hljs-attr\" class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;ts&quot;</span> <span class=\"hljs-attr\" class=\"hljs-attr\">setup</span>&gt;</span><span class=\"javascript\" class=\"javascript\">\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> { useMessageBox, <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">PerfectMessageBox</span> } <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;perfect-message-box&quot;</span>\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> { confirm, controller } = <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">useMessageBox</span>();\n\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">toDoSomething</span> = <span class=\"hljs-keyword\" class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\" class=\"hljs-params\"></span>)=&gt;{\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">await</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">confirm</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;Are you sure?&apos;</span>);\n    <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">doSomthing</span>();\n}\n</span><span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">script</span>&gt;</span>\n</span></code></pre></div></div><p>**注意所有的vue3代码都是使用setup模式来写的，因为我实在无法理解有了setup为什么还要去写options</p><p>通过这种方式，我们可以做到了： 1，支持以slots方式传入自定义内容，契合vue的使用方式。 2，按需引入，如果某个懒加载的路由完全没有使用到MessageBox，那么在加载页面的时候就完全不会包括相关的代码。 3，依旧支持Promise调用，函数式的使用方式令人精神愉悦（划掉）。</p><p>这样的方式看起来十分符合我们的需求，那么我们如何才能做到呢？ conroller的实现是重点，它连接了confirm函数和组件的状态，使得调用confirm函数时传入的参数能够被渲染到组件之中，我们可以先从基础的MessageBox组件出发，看看controller需要提供哪些能力，一个简单的MessageBox demo如下：</p><div class=\"llt-code readonly\"><div class=\"language\">vue</div><div class=\"wrapper\"><pre><code class=\"language-vue\"><span class=\"xml\" class=\"xml\"><span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">teleport</span> <span class=\"hljs-attr\" class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;visible&quot;</span> <span class=\"hljs-attr\" class=\"hljs-attr\">:to</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;body&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">div</span> <span class=\"hljs-attr\" class=\"hljs-attr\">class</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;message-box&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">slot</span>&gt;</span>\n                <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">div</span>&gt;</span>{{title}}<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">slot</span>&gt;</span>\n            <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">button</span> @<span class=\"hljs-attr\" class=\"hljs-attr\">click</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;()=&gt;{$emit(&apos;update:visible&apos;,false);$emit(&apos;confirm&apos;)}&quot;</span>&gt;</span>confirm<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">button</span>&gt;</span>\n            <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">button</span> @<span class=\"hljs-attr\" class=\"hljs-attr\">click</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;()=&gt;{$emit(&apos;update:visible&apos;,false);$emit(&apos;cancel&apos;)}&quot;</span>&gt;</span>cancel<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">button</span>&gt;</span>\n        <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">teleport</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">script</span> <span class=\"hljs-attr\" class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;ts&quot;</span> <span class=\"hljs-attr\" class=\"hljs-attr\">setup</span>&gt;</span><span class=\"javascript\" class=\"javascript\">\ndefineProps&lt;{\n    <span class=\"hljs-attr\" class=\"hljs-attr\">visible</span>: boolean;\n    <span class=\"hljs-attr\" class=\"hljs-attr\">title</span>: string;\n}&gt;()\n\ndefineEmit&lt;{\n    (<span class=\"hljs-attr\" class=\"hljs-attr\">name</span>:<span class=\"hljs-string\" class=\"hljs-string\">&quot;update:visible&quot;</span>, <span class=\"hljs-attr\" class=\"hljs-attr\">value</span>: boolean):<span class=\"hljs-keyword\" class=\"hljs-keyword\">void</span>;\n    (<span class=\"hljs-attr\" class=\"hljs-attr\">name</span>:<span class=\"hljs-string\" class=\"hljs-string\">&quot;confirm&quot;</span>):<span class=\"hljs-keyword\" class=\"hljs-keyword\">void</span>;\n    (<span class=\"hljs-attr\" class=\"hljs-attr\">name</span>:<span class=\"hljs-string\" class=\"hljs-string\">&quot;cancel&quot;</span>):<span class=\"hljs-keyword\" class=\"hljs-keyword\">void</span>;\n}&gt;()\n</span><span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">script</span>&gt;</span>\n</span></code></pre></div></div><p>可以看出，在这里MessageBox是靠Vue的事件来传递用户是否点击了确认或者取消，同时根据父组件传入的visible值来展示或者隐藏自身，那么controller就需要模仿这种事件机制，因为Vue的事件是无法在组件外使用的，可以写出这样的一个controller：</p><div class=\"llt-code readonly\"><div class=\"language\">typescript</div><div class=\"wrapper\"><pre><code class=\"language-typescript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">useMessageBox</span>=(<span class=\"hljs-params\" class=\"hljs-params\"></span>)=&gt;{\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">ref</span>({\n        <span class=\"hljs-attr\" class=\"hljs-attr\">visible</span>: <span class=\"hljs-literal\" class=\"hljs-literal\">false</span>,\n        <span class=\"hljs-attr\" class=\"hljs-attr\">title</span>:<span class=\"hljs-string\" class=\"hljs-string\">&apos;&apos;</span>,\n        <span class=\"hljs-attr\" class=\"hljs-attr\">confirm</span>: <span class=\"hljs-function\" class=\"hljs-function\">()=&gt;</span><span class=\"hljs-literal\" class=\"hljs-literal\">undefined</span>,\n        <span class=\"hljs-attr\" class=\"hljs-attr\">cancel</span>: <span class=\"hljs-function\" class=\"hljs-function\">()=&gt;</span><span class=\"hljs-literal\" class=\"hljs-literal\">undefined</span>,\n    })\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">show</span>=(<span class=\"hljs-params\" class=\"hljs-params\"><span class=\"hljs-attr\" class=\"hljs-attr\">title</span>:<span class=\"hljs-built_in\" class=\"hljs-built_in\">string</span></span>)=&gt;<span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Promise</span>&lt;<span class=\"hljs-built_in\" class=\"hljs-built_in\">void</span>&gt;(<span class=\"hljs-function\" class=\"hljs-function\">(<span class=\"hljs-params\" class=\"hljs-params\">resolve,reject</span>)=&gt;</span>{\n        controller.<span class=\"hljs-property\" class=\"hljs-property\">value</span>={\n            title,\n            <span class=\"hljs-attr\" class=\"hljs-attr\">visible</span>:<span class=\"hljs-literal\" class=\"hljs-literal\">true</span>,\n            <span class=\"hljs-attr\" class=\"hljs-attr\">confirm</span>:<span class=\"hljs-function\" class=\"hljs-function\">()=&gt;</span>{\n                controller.<span class=\"hljs-property\" class=\"hljs-property\">value</span> = { ...controller.<span class=\"hljs-property\" class=\"hljs-property\">value</span>, <span class=\"hljs-attr\" class=\"hljs-attr\">visible</span>: <span class=\"hljs-literal\" class=\"hljs-literal\">false</span> };\n                <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">resolve</span>()\n            },\n            <span class=\"hljs-attr\" class=\"hljs-attr\">cancel</span>:<span class=\"hljs-function\" class=\"hljs-function\">()=&gt;</span>{\n                controller.<span class=\"hljs-property\" class=\"hljs-property\">value</span> = { ...controller.<span class=\"hljs-property\" class=\"hljs-property\">value</span>, <span class=\"hljs-attr\" class=\"hljs-attr\">visible</span>: <span class=\"hljs-literal\" class=\"hljs-literal\">false</span> };\n                <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">reject</span>()\n            }\n        }\n    })\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> {\n        show, controller\n    }\n}\n</code></pre></div></div><p>同时将MessageBox组件修改成这样：</p><div class=\"llt-code readonly\"><div class=\"language\">vue</div><div class=\"wrapper\"><pre><code class=\"language-vue\"><span class=\"xml\" class=\"xml\"><span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">teleport</span> <span class=\"hljs-attr\" class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;visible&quot;</span> <span class=\"hljs-attr\" class=\"hljs-attr\">:to</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;body&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">div</span> <span class=\"hljs-attr\" class=\"hljs-attr\">class</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;message-box&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">slot</span>&gt;</span>\n                <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">div</span>&gt;</span>{{controller.title}}<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">slot</span>&gt;</span>\n            <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">button</span> @<span class=\"hljs-attr\" class=\"hljs-attr\">click</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;controller.confirm()&quot;</span>&gt;</span>confirm<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">button</span>&gt;</span>\n            <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">button</span> @<span class=\"hljs-attr\" class=\"hljs-attr\">click</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;controller.cancel()&quot;</span>&gt;</span>cancel<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">button</span>&gt;</span>\n        <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">teleport</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">script</span> <span class=\"hljs-attr\" class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;ts&quot;</span> <span class=\"hljs-attr\" class=\"hljs-attr\">setup</span>&gt;</span>\ndefineProps&lt;{\n    controller: Controller\n}&gt;()\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">script</span>&gt;</span>\n</span></code></pre></div></div><p>通过巧妙地设置和改变controller的值，使得组件可以不通过props来获取参数并传递相应的事件，这是不是像极了Vuex或者其他类似的状态管理工具的思路？不同的是，这里我们没有依靠任何第三方状态管理框架，仅凭vue/reactivity的能力就办到了，这也侧面说明某种意义上全局的状态管理能力是可以被vue/reactivity取代的。而在这个实例中，我们简单地通过响应式状态的传递实现了组件props和父组件的解耦，子组件可以不再仅靠声明式的props来渲染内容，父组件也有了更多调用子组件能力的方式，完美实现了原版ElMessageBox的功能，并且与Vue的特性完美结合，不再有奇奇怪怪的hack。</p><p>它还有许多衍生用法，例如导出一个<code>useGlobalConfirm</code>方法，并在App.vue根组件下插入MessageBox，使得所有组件或者函数在使用MessageBox时共用同一个实例，完美复刻原版ElMessageBox的用法；也可以通过设置controller的更多属性，来支持传入更多配置例如按钮文案、按钮数量等等，还可以将参数本身设置为响应式对象，可以使MessageBox动态展示正在加载的进度等等，整个使用流程和逻辑更符合Vue的思考方式。</p><p>我把这个组件构建思路应用在了Cent中，这样每个组件都只需要关心自己的工作，不再需要处理额外的状态来管理MessageBox弹窗，整个逻辑条理清晰，十分利于维护。</p><h2 level=\"2\"><strong>思考</strong></h2><p>ElMessageBox采用手动构建和挂载DOM的方式还有另外一层因素，就是多层嵌套的MessageBox，例如二次确认或者多次确认，这时单个MessageBox组件就不够用了，那要如何处理这种情况呢？</p><p>其实解决方法也很简单，我们可以创建一个高阶组件，它专门负责创建重复的组件并自动为组件分配id和层级，把我们的MessageBox包裹起来，就可以了</p><div class=\"llt-code readonly\"><div class=\"language\">vue</div><div class=\"wrapper\"><pre><code class=\"language-vue\"><span class=\"xml\" class=\"xml\"><span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">component</span> <span class=\"hljs-attr\" class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;{component,props,key} in list&quot;</span> <span class=\"hljs-attr\" class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;key&quot;</span> <span class=\"hljs-attr\" class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;component&quot;</span> <span class=\"hljs-attr\" class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;props&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\" class=\"hljs-tag\">&lt;<span class=\"hljs-name\" class=\"hljs-name\">script</span> <span class=\"hljs-attr\" class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\" class=\"hljs-string\">&quot;ts&quot;</span> <span class=\"hljs-attr\" class=\"hljs-attr\">setup</span>&gt;</span><span class=\"javascript\" class=\"javascript\">\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">import</span> type { <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Component</span> } <span class=\"hljs-keyword\" class=\"hljs-keyword\">from</span> <span class=\"hljs-string\" class=\"hljs-string\">&apos;vue&apos;</span>;\n\ndefineProps&lt;{\n    <span class=\"hljs-attr\" class=\"hljs-attr\">list</span>:{\n        <span class=\"hljs-attr\" class=\"hljs-attr\">component</span>:<span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Component</span>,\n        <span class=\"hljs-attr\" class=\"hljs-attr\">props</span>:any,\n        <span class=\"hljs-attr\" class=\"hljs-attr\">key</span>:string\n    }[]\n}&gt;()\n</span><span class=\"hljs-tag\" class=\"hljs-tag\">&lt;/<span class=\"hljs-name\" class=\"hljs-name\">script</span>&gt;</span>\n</span></code></pre></div></div><p>不过同样的，这样也会导致MessageBox失去对自定义slot的支持。大多数情况下，二次确认的弹窗数量不会超过两个因此完全可以将二次确认的MessageBox放在根组件中，而将首次弹窗的MessageBox放在当前的组件，这样也更方便理解逻辑。</p><h2 level=\"2\"><strong>Vue的不足</strong></h2><p>描述Vue和React、Angular之类的框架优劣之争已经有了很多说法，不过我在使用Vue的过程中最大一个痛点就是Vue的单文件写法，单文件在代码组织方面是有优势的，可以方便区分不同的组件，做到许多编译期的优化，但是一个Vue文件只能有一个组件的设计也让我不得不写很多额外的临时组件，例如渲染一个只会在当前组件用到的列表，我实在不想为了单独的列表项目去想一个新名字，为这些临时组件新建一个文件夹，再多写好几遍import、export语句。在react或者其他JSX语言的框架中，我可以把这些临时组件写在一个文件里，随时调用，当然vue也提供了JSX的写法，但是那样就会失去编译器的模板优化，并且vue的JSX与其他框架的语义并不完全相同，一些特殊的用法还得重新学习，显然算不上优雅的解决方法。</p><script type=\"module\">const injectHtml = (root, html) => {\n  const iframe = document.createElement(\"iframe\");\n  const htmlContent = `<html><head></head><body>${html}</body></html>`;\n  iframe.style.width = \"100%\";\n  iframe.style.height = \"100%\";\n  iframe.onload = () => {\n    const doc = iframe.contentDocument || iframe.contentWindow?.document;\n    if (!doc) {\n      return;\n    }\n    doc.open();\n    doc.write(htmlContent);\n    doc.close();\n  };\n  root.replaceChildren(iframe);\n}\n  document.querySelectorAll('.playground')?.forEach(el=>{\n    const html = el.getAttribute('data-html');\n    if (html) {\n      injectHtml(el,html);\n    }\n    const indicator = document.createElement(\"div\");\n    indicator.className = \"indicator\";\n    const showCode = document.createElement(\"div\");\n    showCode.className = \"show-code\";\n    showCode.innerText = \"code\";\n    showCode.onclick = () => {\n      el.parentElement.classList.remove(\"preview-only\");\n    };\n    const showPreview = document.createElement(\"div\");\n    showPreview.className = \"show-preview\";\n    showPreview.innerText = \"preview\";\n    showPreview.onclick = () => {\n      el.parentElement.classList.add(\"preview-only\");\n    };\n    indicator.appendChild(showCode);\n    indicator.appendChild(showPreview);\n    el.parentElement.appendChild(indicator);\n    if (window.screen.width < 768) {\n      showPreview.click();\n    }\n  });</script>","id":"2022年了如何写出优雅的vue3组件","path":"/posts/2022年了如何写出优雅的vue3组件.json"}