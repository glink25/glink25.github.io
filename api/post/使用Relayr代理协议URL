{"content":"{\"__ud_title\":\"使用Relayr代理协议URL\",\"__ud_tags\":[\"Cent\"],\"__ud_update_time\":1769765741242,\"__ud_create_time\":1769765697962,\"__ud_draft\":false,\"type\":\"doc\",\"content\":[{\"type\":\"heading\",\"attrs\":{\"level\":1,\"id\":\"使用Relayr代理协议URL\"},\"content\":[{\"type\":\"text\",\"text\":\"使用Relayr代理协议URL\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在前端开发中，我们经常遇到跨域、需要动态更换 API 代理或是在请求头中注入鉴权信息的需求。本文将介绍一种通过 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"Fetch 劫持\"},{\"type\":\"text\",\"text\":\" 结合 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"自定义伪协议\"},{\"type\":\"text\",\"text\":\" 的方案，实现一套优雅且灵活的代理中间件。\"}]},{\"type\":\"blockquote\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在Cent中，所有允许输入自定义URL的地方都支持Relayr协议自定义代理，但是你需要自己实现一个支持该协议的后端服务，可以通过Cloudflare Workers或者Supabase Edge Function部署。\"}]}]},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"1-协议设计\"},\"content\":[{\"type\":\"text\",\"text\":\"1. 协议设计\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"传统的 URL 传参容易受到特殊字符（如 JSON 中的引号、大括号）的影响，导致解析失败。我们采用 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"Base64 编码配置\"},{\"type\":\"text\",\"text\":\" 的方案：\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"id\":\"协议格式\"},\"content\":[{\"type\":\"text\",\"text\":\"协议格式\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"proxy://<base64_config>@<target_path_suffix>\"}]},{\"type\":\"bulletList\",\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"proxy://\"},{\"type\":\"text\",\"text\":\": 协议头，用于中间件识别。\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"<base64_config>\"},{\"type\":\"text\",\"text\":\": 包含代理服务器地址、目标基准地址、额外 Header 的 JSON 对象，并经过 Base64 编码。\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"@\"},{\"type\":\"text\",\"text\":\": 分隔符。\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"<target_path_suffix>\"},{\"type\":\"text\",\"text\":\": 具体的 API 路径后缀。\"}]}]}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"id\":\"数据结构示例\"},\"content\":[{\"type\":\"text\",\"text\":\"数据结构示例\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"编码前的 JSON 配置：\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"JSON\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"json\"},\"content\":[{\"type\":\"text\",\"text\":\"{\\n  \\\"proxyUrl\\\": \\\"https://my-server.com/proxy\\\",\\n  \\\"targetBase\\\": \\\"https://api.openai.com\\\",\\n  \\\"headers\\\": {\\n    \\\"x-proxy-key\\\": \\\"Bearer sk-123\\\"\\n  }\\n}\\n\"}]},{\"type\":\"horizontalRule\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"2-前端中间件实现\"},\"content\":[{\"type\":\"text\",\"text\":\"2. 前端中间件实现\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"基于你已有的 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"registerProxy\"},{\"type\":\"text\",\"text\":\" 劫持框架，我们编写如下解析逻辑：\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"TypeScript\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"javascript\"},\"content\":[{\"type\":\"text\",\"text\":\"const proxyMiddleware: Handler = async (url, options, next) => {\\n    const urlStr = url.toString();\\n\\n    // 1. 识别协议\\n    if (!urlStr.startsWith('proxy://')) {\\n        return next(url, options);\\n    }\\n\\n    try {\\n        // 2. 拆分 Base64 配置与路径后缀\\n        const mainPart = urlStr.slice(8); // 移除 'proxy://'\\n        const [configBase64, ...pathParts] = mainPart.split('@');\\n        const targetPathSuffix = pathParts.join('@'); // 防止路径中也带有 @\\n\\n        // 3. 解码并解析配置\\n        const configJson = JSON.parse(atob(configBase64));\\n        const { proxyUrl, targetBase, headers: extraHeaders } = configJson;\\n\\n        // 拼接最终目标地址\\n        const finalTargetUrl = `${targetBase}${targetPathSuffix}`;\\n\\n        // 4. 转换请求参数\\n        const newOptions: RequestInit = {\\n            ...options,\\n            method: 'POST', // 代理请求统一转为 POST 以便在 Body 中携带 target\\n            headers: {\\n                ...options.headers,\\n                ...extraHeaders,\\n                'Content-Type': 'application/json'\\n            },\\n            body: JSON.stringify({\\n                target: finalTargetUrl,\\n                payload: options.body ? \\n                         (typeof options.body === 'string' ? JSON.parse(options.body) : options.body) \\n                         : null\\n            })\\n        };\\n\\n        console.log(`[Proxy] Forwarding to: ${finalTargetUrl}`);\\n        return next(proxyUrl, newOptions);\\n    } catch (err) {\\n        console.error(\\\"[Proxy Error]\\\", err);\\n        return next(url, options);\\n    }\\n};\\n\"}]},{\"type\":\"horizontalRule\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"3-代理后端实现-Nodejs-示例\"},\"content\":[{\"type\":\"text\",\"text\":\"3. 代理后端实现 (Node.js 示例)\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"后端代理服务器需要接收 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"POST\"},{\"type\":\"text\",\"text\":\" 请求，解析其中的 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"target\"},{\"type\":\"text\",\"text\":\" 字段，并携带请求头转发。\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"JavaScript\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"javascript\"},\"content\":[{\"type\":\"text\",\"text\":\"const express = require('express');\\nconst axios = require('axios');\\nconst app = express();\\n\\napp.use(express.json());\\n\\napp.post('/proxy', async (req, res) => {\\n    const { target, payload } = req.body;\\n    \\n    // 获取前端注入的额外 Header (例如 x-proxy-key)\\n    const proxyHeaders = { ...req.headers };\\n    // 移除宿主信息，防止目标服务器校验失败\\n    delete proxyHeaders.host; \\n\\n    try {\\n        console.log(`Forwarding request to: ${target}`);\\n        \\n        const response = await axios({\\n            method: 'POST', // 或根据逻辑透传原 method\\n            url: target,\\n            data: payload,\\n            headers: proxyHeaders,\\n            timeout: 10000\\n        });\\n\\n        res.status(response.status).send(response.data);\\n    } catch (error) {\\n        const status = error.response ? error.response.status : 500;\\n        res.status(status).send(error.message);\\n    }\\n});\\n\\napp.listen(3000, () => console.log('Proxy Server running on port 3000'));\\n\"}]},{\"type\":\"horizontalRule\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"4-如何使用\"},\"content\":[{\"type\":\"text\",\"text\":\"4. 如何使用\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"在业务代码中，你可以通过工具函数生成这个复合 URL：\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"id\":\"生成器工具\"},\"content\":[{\"type\":\"text\",\"text\":\"生成器工具\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"JavaScript\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"javascript\"},\"content\":[{\"type\":\"text\",\"text\":\"function createProxyUrl(config, apiPath) {\\n    const base64 = btoa(JSON.stringify(config));\\n    return `proxy://${base64}@${apiPath}`;\\n}\\n\"}]},{\"type\":\"heading\",\"attrs\":{\"level\":3,\"id\":\"发起请求\"},\"content\":[{\"type\":\"text\",\"text\":\"发起请求\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"JavaScript\"}]},{\"type\":\"codeBlock\",\"attrs\":{\"language\":\"javascript\"},\"content\":[{\"type\":\"text\",\"text\":\"const config = {\\n    proxyUrl: \\\"http://localhost:3000/proxy\\\",\\n    targetBase: \\\"https://api.openai.com\\\",\\n    headers: { \\\"Authorization\\\": \\\"Bearer TOKEN\\\" }\\n};\\n\\n// 实际请求地址：proxy://ey...@{config}@/v1/chat/completions\\nfetch(createProxyUrl(config, '/v1/chat/completions'), {\\n    method: 'POST',\\n    body: JSON.stringify({ model: 'gpt-3.5-turbo' })\\n});\\n\"}]},{\"type\":\"horizontalRule\"},{\"type\":\"heading\",\"attrs\":{\"level\":2,\"id\":\"5-总结\"},\"content\":[{\"type\":\"text\",\"text\":\"5. 总结\"}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"该方案的优势在于：\"}]},{\"type\":\"orderedList\",\"attrs\":{\"start\":1,\"type\":null},\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"高度封装\"},{\"type\":\"text\",\"text\":\"：业务代码无需关心代理服务器的具体实现。\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"兼容性强\"},{\"type\":\"text\",\"text\":\"：Base64 避免了 URL 特殊字符带来的解析噩梦。\"}]}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"动态性\"},{\"type\":\"text\",\"text\":\"：可以随时在前端通过修改 \"},{\"type\":\"text\",\"marks\":[{\"type\":\"code\"}],\"text\":\"config\"},{\"type\":\"text\",\"text\":\" 来切换不同的代理节点或目标 API。\"}]}]}]},{\"type\":\"blockquote\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"marks\":[{\"type\":\"bold\"}],\"text\":\"注意\"},{\"type\":\"text\",\"text\":\"：由于 Base64 编码会增加字符串体积，且 URL 长度在不同浏览器中有限制（如 Chrome 限制为 2MB），本方案适用于配置信息中等的场景。\"}]}]},{\"type\":\"horizontalRule\"}]}","title":"使用Relayr代理协议URL","tags":["Cent"],"updateTime":1769765741242,"createTime":1769765697962,"draft":false,"intro":"在前端开发中，我们经常遇到跨域、需要动态更换 API 代理或是在请求头中注入鉴权信息的需求。本文将介绍一种通过 Fetch 劫持 结合 自定义伪协议 的方案，实现一套优雅且灵活的代理中间件。","html":"<h1 level=\"1\" id=\"使用Relayr代理协议URL\">使用Relayr代理协议URL</h1><p>在前端开发中，我们经常遇到跨域、需要动态更换 API 代理或是在请求头中注入鉴权信息的需求。本文将介绍一种通过 <strong>Fetch 劫持</strong> 结合 <strong>自定义伪协议</strong> 的方案，实现一套优雅且灵活的代理中间件。</p><blockquote><p>在Cent中，所有允许输入自定义URL的地方都支持Relayr协议自定义代理，但是你需要自己实现一个支持该协议的后端服务，可以通过Cloudflare Workers或者Supabase Edge Function部署。</p></blockquote><h2 level=\"2\" id=\"1-协议设计\">1. 协议设计</h2><p>传统的 URL 传参容易受到特殊字符（如 JSON 中的引号、大括号）的影响，导致解析失败。我们采用 <strong>Base64 编码配置</strong> 的方案：</p><h3 level=\"3\" id=\"协议格式\">协议格式</h3><p><code>proxy://&lt;base64_config&gt;@&lt;target_path_suffix&gt;</code></p><ul><li><p><code>proxy://</code>: 协议头，用于中间件识别。</p></li><li><p><code>&lt;base64_config&gt;</code>: 包含代理服务器地址、目标基准地址、额外 Header 的 JSON 对象，并经过 Base64 编码。</p></li><li><p><code>@</code>: 分隔符。</p></li><li><p><code>&lt;target_path_suffix&gt;</code>: 具体的 API 路径后缀。</p></li></ul><h3 level=\"3\" id=\"数据结构示例\">数据结构示例</h3><p>编码前的 JSON 配置：</p><p>JSON</p><div class=\"llt-code readonly\"><div class=\"language\">json</div><div class=\"wrapper\"><pre><code class=\"language-json\"><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\" class=\"hljs-attr\">&quot;proxyUrl&quot;</span><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;https://my-server.com/proxy&quot;</span><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\" class=\"hljs-attr\">&quot;targetBase&quot;</span><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;https://api.openai.com&quot;</span><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\" class=\"hljs-attr\">&quot;headers&quot;</span><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\" class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\" class=\"hljs-attr\">&quot;x-proxy-key&quot;</span><span class=\"hljs-punctuation\" class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\" class=\"hljs-string\">&quot;Bearer sk-123&quot;</span>\n  <span class=\"hljs-punctuation\" class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\" class=\"hljs-punctuation\">}</span>\n</code></pre></div></div><hr><h2 level=\"2\" id=\"2-前端中间件实现\">2. 前端中间件实现</h2><p>基于你已有的 <code>registerProxy</code> 劫持框架，我们编写如下解析逻辑：</p><p>TypeScript</p><div class=\"llt-code readonly\"><div class=\"language\">javascript</div><div class=\"wrapper\"><pre><code class=\"language-javascript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\" class=\"hljs-attr\">proxyMiddleware</span>: <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">Handler</span> = <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">async</span> (url, options, next) =&gt; {\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> urlStr = url.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">toString</span>();\n\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 1. 识别协议</span>\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">if</span> (!urlStr.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">startsWith</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;proxy://&apos;</span>)) {\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">next</span>(url, options);\n    }\n\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\" class=\"hljs-comment\">// 2. 拆分 Base64 配置与路径后缀</span>\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> mainPart = urlStr.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">slice</span>(<span class=\"hljs-number\" class=\"hljs-number\">8</span>); <span class=\"hljs-comment\" class=\"hljs-comment\">// 移除 &apos;proxy://&apos;</span>\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> [configBase64, ...pathParts] = mainPart.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">split</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;@&apos;</span>);\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> targetPathSuffix = pathParts.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">join</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;@&apos;</span>); <span class=\"hljs-comment\" class=\"hljs-comment\">// 防止路径中也带有 @</span>\n\n        <span class=\"hljs-comment\" class=\"hljs-comment\">// 3. 解码并解析配置</span>\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> configJson = <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">JSON</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">parse</span>(<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">atob</span>(configBase64));\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> { proxyUrl, targetBase, <span class=\"hljs-attr\" class=\"hljs-attr\">headers</span>: extraHeaders } = configJson;\n\n        <span class=\"hljs-comment\" class=\"hljs-comment\">// 拼接最终目标地址</span>\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> finalTargetUrl = <span class=\"hljs-string\" class=\"hljs-string\">`<span class=\"hljs-subst\" class=\"hljs-subst\">${targetBase}</span><span class=\"hljs-subst\" class=\"hljs-subst\">${targetPathSuffix}</span>`</span>;\n\n        <span class=\"hljs-comment\" class=\"hljs-comment\">// 4. 转换请求参数</span>\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\" class=\"hljs-attr\">newOptions</span>: <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">RequestInit</span> = {\n            ...options,\n            <span class=\"hljs-attr\" class=\"hljs-attr\">method</span>: <span class=\"hljs-string\" class=\"hljs-string\">&apos;POST&apos;</span>, <span class=\"hljs-comment\" class=\"hljs-comment\">// 代理请求统一转为 POST 以便在 Body 中携带 target</span>\n            <span class=\"hljs-attr\" class=\"hljs-attr\">headers</span>: {\n                ...options.<span class=\"hljs-property\" class=\"hljs-property\">headers</span>,\n                ...extraHeaders,\n                <span class=\"hljs-string\" class=\"hljs-string\">&apos;Content-Type&apos;</span>: <span class=\"hljs-string\" class=\"hljs-string\">&apos;application/json&apos;</span>\n            },\n            <span class=\"hljs-attr\" class=\"hljs-attr\">body</span>: <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">JSON</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">stringify</span>({\n                <span class=\"hljs-attr\" class=\"hljs-attr\">target</span>: finalTargetUrl,\n                <span class=\"hljs-attr\" class=\"hljs-attr\">payload</span>: options.<span class=\"hljs-property\" class=\"hljs-property\">body</span> ? \n                         (<span class=\"hljs-keyword\" class=\"hljs-keyword\">typeof</span> options.<span class=\"hljs-property\" class=\"hljs-property\">body</span> === <span class=\"hljs-string\" class=\"hljs-string\">&apos;string&apos;</span> ? <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">JSON</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">parse</span>(options.<span class=\"hljs-property\" class=\"hljs-property\">body</span>) : options.<span class=\"hljs-property\" class=\"hljs-property\">body</span>) \n                         : <span class=\"hljs-literal\" class=\"hljs-literal\">null</span>\n            })\n        };\n\n        <span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">console</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">log</span>(<span class=\"hljs-string\" class=\"hljs-string\">`[Proxy] Forwarding to: <span class=\"hljs-subst\" class=\"hljs-subst\">${finalTargetUrl}</span>`</span>);\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">next</span>(proxyUrl, newOptions);\n    } <span class=\"hljs-keyword\" class=\"hljs-keyword\">catch</span> (err) {\n        <span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">console</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">error</span>(<span class=\"hljs-string\" class=\"hljs-string\">&quot;[Proxy Error]&quot;</span>, err);\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">next</span>(url, options);\n    }\n};\n</code></pre></div></div><hr><h2 level=\"2\" id=\"3-代理后端实现-Nodejs-示例\">3. 代理后端实现 (Node.js 示例)</h2><p>后端代理服务器需要接收 <code>POST</code> 请求，解析其中的 <code>target</code> 字段，并携带请求头转发。</p><p>JavaScript</p><div class=\"llt-code readonly\"><div class=\"language\">javascript</div><div class=\"wrapper\"><pre><code class=\"language-javascript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> express = <span class=\"hljs-built_in\" class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;express&apos;</span>);\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> axios = <span class=\"hljs-built_in\" class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;axios&apos;</span>);\n<span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">express</span>();\n\napp.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">use</span>(express.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">json</span>());\n\napp.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">post</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;/proxy&apos;</span>, <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">async</span> (req, res) =&gt; {\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> { target, payload } = req.<span class=\"hljs-property\" class=\"hljs-property\">body</span>;\n    \n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 获取前端注入的额外 Header (例如 x-proxy-key)</span>\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> proxyHeaders = { ...req.<span class=\"hljs-property\" class=\"hljs-property\">headers</span> };\n    <span class=\"hljs-comment\" class=\"hljs-comment\">// 移除宿主信息，防止目标服务器校验失败</span>\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">delete</span> proxyHeaders.<span class=\"hljs-property\" class=\"hljs-property\">host</span>; \n\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">console</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">log</span>(<span class=\"hljs-string\" class=\"hljs-string\">`Forwarding request to: <span class=\"hljs-subst\" class=\"hljs-subst\">${target}</span>`</span>);\n        \n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\" class=\"hljs-keyword\">await</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">axios</span>({\n            <span class=\"hljs-attr\" class=\"hljs-attr\">method</span>: <span class=\"hljs-string\" class=\"hljs-string\">&apos;POST&apos;</span>, <span class=\"hljs-comment\" class=\"hljs-comment\">// 或根据逻辑透传原 method</span>\n            <span class=\"hljs-attr\" class=\"hljs-attr\">url</span>: target,\n            <span class=\"hljs-attr\" class=\"hljs-attr\">data</span>: payload,\n            <span class=\"hljs-attr\" class=\"hljs-attr\">headers</span>: proxyHeaders,\n            <span class=\"hljs-attr\" class=\"hljs-attr\">timeout</span>: <span class=\"hljs-number\" class=\"hljs-number\">10000</span>\n        });\n\n        res.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">status</span>(response.<span class=\"hljs-property\" class=\"hljs-property\">status</span>).<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">send</span>(response.<span class=\"hljs-property\" class=\"hljs-property\">data</span>);\n    } <span class=\"hljs-keyword\" class=\"hljs-keyword\">catch</span> (error) {\n        <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> status = error.<span class=\"hljs-property\" class=\"hljs-property\">response</span> ? error.<span class=\"hljs-property\" class=\"hljs-property\">response</span>.<span class=\"hljs-property\" class=\"hljs-property\">status</span> : <span class=\"hljs-number\" class=\"hljs-number\">500</span>;\n        res.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">status</span>(status).<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">send</span>(error.<span class=\"hljs-property\" class=\"hljs-property\">message</span>);\n    }\n});\n\napp.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">listen</span>(<span class=\"hljs-number\" class=\"hljs-number\">3000</span>, <span class=\"hljs-function\" class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-variable,language_\" class=\"hljs-variable,language_\">console</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">log</span>(<span class=\"hljs-string\" class=\"hljs-string\">&apos;Proxy Server running on port 3000&apos;</span>));\n</code></pre></div></div><hr><h2 level=\"2\" id=\"4-如何使用\">4. 如何使用</h2><p>在业务代码中，你可以通过工具函数生成这个复合 URL：</p><h3 level=\"3\" id=\"生成器工具\">生成器工具</h3><p>JavaScript</p><div class=\"llt-code readonly\"><div class=\"language\">javascript</div><div class=\"wrapper\"><pre><code class=\"language-javascript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">function</span> <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createProxyUrl</span>(<span class=\"hljs-params\" class=\"hljs-params\">config, apiPath</span>) {\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> base64 = <span class=\"hljs-title,function_\" class=\"hljs-title,function_\">btoa</span>(<span class=\"hljs-title,class_\" class=\"hljs-title,class_\">JSON</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">stringify</span>(config));\n    <span class=\"hljs-keyword\" class=\"hljs-keyword\">return</span> <span class=\"hljs-string\" class=\"hljs-string\">`proxy://<span class=\"hljs-subst\" class=\"hljs-subst\">${base64}</span>@<span class=\"hljs-subst\" class=\"hljs-subst\">${apiPath}</span>`</span>;\n}\n</code></pre></div></div><h3 level=\"3\" id=\"发起请求\">发起请求</h3><p>JavaScript</p><div class=\"llt-code readonly\"><div class=\"language\">javascript</div><div class=\"wrapper\"><pre><code class=\"language-javascript\"><span class=\"hljs-keyword\" class=\"hljs-keyword\">const</span> config = {\n    <span class=\"hljs-attr\" class=\"hljs-attr\">proxyUrl</span>: <span class=\"hljs-string\" class=\"hljs-string\">&quot;http://localhost:3000/proxy&quot;</span>,\n    <span class=\"hljs-attr\" class=\"hljs-attr\">targetBase</span>: <span class=\"hljs-string\" class=\"hljs-string\">&quot;https://api.openai.com&quot;</span>,\n    <span class=\"hljs-attr\" class=\"hljs-attr\">headers</span>: { <span class=\"hljs-string\" class=\"hljs-string\">&quot;Authorization&quot;</span>: <span class=\"hljs-string\" class=\"hljs-string\">&quot;Bearer TOKEN&quot;</span> }\n};\n\n<span class=\"hljs-comment\" class=\"hljs-comment\">// 实际请求地址：proxy://ey...@{config}@/v1/chat/completions</span>\n<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">fetch</span>(<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">createProxyUrl</span>(config, <span class=\"hljs-string\" class=\"hljs-string\">&apos;/v1/chat/completions&apos;</span>), {\n    <span class=\"hljs-attr\" class=\"hljs-attr\">method</span>: <span class=\"hljs-string\" class=\"hljs-string\">&apos;POST&apos;</span>,\n    <span class=\"hljs-attr\" class=\"hljs-attr\">body</span>: <span class=\"hljs-title,class_\" class=\"hljs-title,class_\">JSON</span>.<span class=\"hljs-title,function_\" class=\"hljs-title,function_\">stringify</span>({ <span class=\"hljs-attr\" class=\"hljs-attr\">model</span>: <span class=\"hljs-string\" class=\"hljs-string\">&apos;gpt-3.5-turbo&apos;</span> })\n});\n</code></pre></div></div><hr><h2 level=\"2\" id=\"5-总结\">5. 总结</h2><p>该方案的优势在于：</p><ol><li><p><strong>高度封装</strong>：业务代码无需关心代理服务器的具体实现。</p></li><li><p><strong>兼容性强</strong>：Base64 避免了 URL 特殊字符带来的解析噩梦。</p></li><li><p><strong>动态性</strong>：可以随时在前端通过修改 <code>config</code> 来切换不同的代理节点或目标 API。</p></li></ol><blockquote><p><strong>注意</strong>：由于 Base64 编码会增加字符串体积，且 URL 长度在不同浏览器中有限制（如 Chrome 限制为 2MB），本方案适用于配置信息中等的场景。</p></blockquote><hr><script type=\"module\">const injectHtml = (root, html) => {\n  const iframe = document.createElement(\"iframe\");\n  const htmlContent = `<html><head></head><body>${html}</body></html>`;\n  iframe.style.width = \"100%\";\n  iframe.style.height = \"100%\";\n  iframe.onload = () => {\n    const doc = iframe.contentDocument || iframe.contentWindow?.document;\n    if (!doc) {\n      return;\n    }\n    doc.open();\n    doc.write(htmlContent);\n    doc.close();\n  };\n  root.replaceChildren(iframe);\n}\n  document.querySelectorAll('.playground')?.forEach(el=>{\n    const html = el.getAttribute('data-html');\n    if (html) {\n      injectHtml(el,html);\n    }\n    const indicator = document.createElement(\"div\");\n    indicator.className = \"indicator\";\n    const showCode = document.createElement(\"div\");\n    showCode.className = \"show-code\";\n    showCode.innerText = \"code\";\n    showCode.onclick = () => {\n      el.parentElement.classList.remove(\"preview-only\");\n    };\n    const showPreview = document.createElement(\"div\");\n    showPreview.className = \"show-preview\";\n    showPreview.innerText = \"preview\";\n    showPreview.onclick = () => {\n      el.parentElement.classList.add(\"preview-only\");\n    };\n    indicator.appendChild(showCode);\n    indicator.appendChild(showPreview);\n    el.parentElement.appendChild(indicator);\n    if (window.screen.width < 768) {\n      showPreview.click();\n    }\n  });</script>","id":"使用Relayr代理协议URL","path":"/posts/使用Relayr代理协议URL.json"}