{"__ud_title":"使用Relayr代理协议URL","__ud_tags":["Cent"],"__ud_update_time":1769765741242,"__ud_create_time":1769765697962,"__ud_draft":false,"type":"doc","content":[{"type":"heading","attrs":{"level":1,"id":"使用Relayr代理协议URL"},"content":[{"type":"text","text":"使用Relayr代理协议URL"}]},{"type":"paragraph","content":[{"type":"text","text":"在前端开发中，我们经常遇到跨域、需要动态更换 API 代理或是在请求头中注入鉴权信息的需求。本文将介绍一种通过 "},{"type":"text","marks":[{"type":"bold"}],"text":"Fetch 劫持"},{"type":"text","text":" 结合 "},{"type":"text","marks":[{"type":"bold"}],"text":"自定义伪协议"},{"type":"text","text":" 的方案，实现一套优雅且灵活的代理中间件。"}]},{"type":"blockquote","content":[{"type":"paragraph","content":[{"type":"text","text":"在Cent中，所有允许输入自定义URL的地方都支持Relayr协议自定义代理，但是你需要自己实现一个支持该协议的后端服务，可以通过Cloudflare Workers或者Supabase Edge Function部署。"}]}]},{"type":"heading","attrs":{"level":2,"id":"1-协议设计"},"content":[{"type":"text","text":"1. 协议设计"}]},{"type":"paragraph","content":[{"type":"text","text":"传统的 URL 传参容易受到特殊字符（如 JSON 中的引号、大括号）的影响，导致解析失败。我们采用 "},{"type":"text","marks":[{"type":"bold"}],"text":"Base64 编码配置"},{"type":"text","text":" 的方案："}]},{"type":"heading","attrs":{"level":3,"id":"协议格式"},"content":[{"type":"text","text":"协议格式"}]},{"type":"paragraph","content":[{"type":"text","marks":[{"type":"code"}],"text":"proxy://<base64_config>@<target_path_suffix>"}]},{"type":"bulletList","content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","marks":[{"type":"code"}],"text":"proxy://"},{"type":"text","text":": 协议头，用于中间件识别。"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","marks":[{"type":"code"}],"text":"<base64_config>"},{"type":"text","text":": 包含代理服务器地址、目标基准地址、额外 Header 的 JSON 对象，并经过 Base64 编码。"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","marks":[{"type":"code"}],"text":"@"},{"type":"text","text":": 分隔符。"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","marks":[{"type":"code"}],"text":"<target_path_suffix>"},{"type":"text","text":": 具体的 API 路径后缀。"}]}]}]},{"type":"heading","attrs":{"level":3,"id":"数据结构示例"},"content":[{"type":"text","text":"数据结构示例"}]},{"type":"paragraph","content":[{"type":"text","text":"编码前的 JSON 配置："}]},{"type":"paragraph","content":[{"type":"text","text":"JSON"}]},{"type":"codeBlock","attrs":{"language":"json"},"content":[{"type":"text","text":"{\n  \"proxyUrl\": \"https://my-server.com/proxy\",\n  \"targetBase\": \"https://api.openai.com\",\n  \"headers\": {\n    \"x-proxy-key\": \"Bearer sk-123\"\n  }\n}\n"}]},{"type":"horizontalRule"},{"type":"heading","attrs":{"level":2,"id":"2-前端中间件实现"},"content":[{"type":"text","text":"2. 前端中间件实现"}]},{"type":"paragraph","content":[{"type":"text","text":"基于你已有的 "},{"type":"text","marks":[{"type":"code"}],"text":"registerProxy"},{"type":"text","text":" 劫持框架，我们编写如下解析逻辑："}]},{"type":"paragraph","content":[{"type":"text","text":"TypeScript"}]},{"type":"codeBlock","attrs":{"language":"javascript"},"content":[{"type":"text","text":"const proxyMiddleware: Handler = async (url, options, next) => {\n    const urlStr = url.toString();\n\n    // 1. 识别协议\n    if (!urlStr.startsWith('proxy://')) {\n        return next(url, options);\n    }\n\n    try {\n        // 2. 拆分 Base64 配置与路径后缀\n        const mainPart = urlStr.slice(8); // 移除 'proxy://'\n        const [configBase64, ...pathParts] = mainPart.split('@');\n        const targetPathSuffix = pathParts.join('@'); // 防止路径中也带有 @\n\n        // 3. 解码并解析配置\n        const configJson = JSON.parse(atob(configBase64));\n        const { proxyUrl, targetBase, headers: extraHeaders } = configJson;\n\n        // 拼接最终目标地址\n        const finalTargetUrl = `${targetBase}${targetPathSuffix}`;\n\n        // 4. 转换请求参数\n        const newOptions: RequestInit = {\n            ...options,\n            method: 'POST', // 代理请求统一转为 POST 以便在 Body 中携带 target\n            headers: {\n                ...options.headers,\n                ...extraHeaders,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                target: finalTargetUrl,\n                payload: options.body ? \n                         (typeof options.body === 'string' ? JSON.parse(options.body) : options.body) \n                         : null\n            })\n        };\n\n        console.log(`[Proxy] Forwarding to: ${finalTargetUrl}`);\n        return next(proxyUrl, newOptions);\n    } catch (err) {\n        console.error(\"[Proxy Error]\", err);\n        return next(url, options);\n    }\n};\n"}]},{"type":"horizontalRule"},{"type":"heading","attrs":{"level":2,"id":"3-代理后端实现-Nodejs-示例"},"content":[{"type":"text","text":"3. 代理后端实现 (Node.js 示例)"}]},{"type":"paragraph","content":[{"type":"text","text":"后端代理服务器需要接收 "},{"type":"text","marks":[{"type":"code"}],"text":"POST"},{"type":"text","text":" 请求，解析其中的 "},{"type":"text","marks":[{"type":"code"}],"text":"target"},{"type":"text","text":" 字段，并携带请求头转发。"}]},{"type":"paragraph","content":[{"type":"text","text":"JavaScript"}]},{"type":"codeBlock","attrs":{"language":"javascript"},"content":[{"type":"text","text":"const express = require('express');\nconst axios = require('axios');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/proxy', async (req, res) => {\n    const { target, payload } = req.body;\n    \n    // 获取前端注入的额外 Header (例如 x-proxy-key)\n    const proxyHeaders = { ...req.headers };\n    // 移除宿主信息，防止目标服务器校验失败\n    delete proxyHeaders.host; \n\n    try {\n        console.log(`Forwarding request to: ${target}`);\n        \n        const response = await axios({\n            method: 'POST', // 或根据逻辑透传原 method\n            url: target,\n            data: payload,\n            headers: proxyHeaders,\n            timeout: 10000\n        });\n\n        res.status(response.status).send(response.data);\n    } catch (error) {\n        const status = error.response ? error.response.status : 500;\n        res.status(status).send(error.message);\n    }\n});\n\napp.listen(3000, () => console.log('Proxy Server running on port 3000'));\n"}]},{"type":"horizontalRule"},{"type":"heading","attrs":{"level":2,"id":"4-如何使用"},"content":[{"type":"text","text":"4. 如何使用"}]},{"type":"paragraph","content":[{"type":"text","text":"在业务代码中，你可以通过工具函数生成这个复合 URL："}]},{"type":"heading","attrs":{"level":3,"id":"生成器工具"},"content":[{"type":"text","text":"生成器工具"}]},{"type":"paragraph","content":[{"type":"text","text":"JavaScript"}]},{"type":"codeBlock","attrs":{"language":"javascript"},"content":[{"type":"text","text":"function createProxyUrl(config, apiPath) {\n    const base64 = btoa(JSON.stringify(config));\n    return `proxy://${base64}@${apiPath}`;\n}\n"}]},{"type":"heading","attrs":{"level":3,"id":"发起请求"},"content":[{"type":"text","text":"发起请求"}]},{"type":"paragraph","content":[{"type":"text","text":"JavaScript"}]},{"type":"codeBlock","attrs":{"language":"javascript"},"content":[{"type":"text","text":"const config = {\n    proxyUrl: \"http://localhost:3000/proxy\",\n    targetBase: \"https://api.openai.com\",\n    headers: { \"Authorization\": \"Bearer TOKEN\" }\n};\n\n// 实际请求地址：proxy://ey...@{config}@/v1/chat/completions\nfetch(createProxyUrl(config, '/v1/chat/completions'), {\n    method: 'POST',\n    body: JSON.stringify({ model: 'gpt-3.5-turbo' })\n});\n"}]},{"type":"horizontalRule"},{"type":"heading","attrs":{"level":2,"id":"5-总结"},"content":[{"type":"text","text":"5. 总结"}]},{"type":"paragraph","content":[{"type":"text","text":"该方案的优势在于："}]},{"type":"orderedList","attrs":{"start":1,"type":null},"content":[{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","marks":[{"type":"bold"}],"text":"高度封装"},{"type":"text","text":"：业务代码无需关心代理服务器的具体实现。"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","marks":[{"type":"bold"}],"text":"兼容性强"},{"type":"text","text":"：Base64 避免了 URL 特殊字符带来的解析噩梦。"}]}]},{"type":"listItem","content":[{"type":"paragraph","content":[{"type":"text","marks":[{"type":"bold"}],"text":"动态性"},{"type":"text","text":"：可以随时在前端通过修改 "},{"type":"text","marks":[{"type":"code"}],"text":"config"},{"type":"text","text":" 来切换不同的代理节点或目标 API。"}]}]}]},{"type":"blockquote","content":[{"type":"paragraph","content":[{"type":"text","marks":[{"type":"bold"}],"text":"注意"},{"type":"text","text":"：由于 Base64 编码会增加字符串体积，且 URL 长度在不同浏览器中有限制（如 Chrome 限制为 2MB），本方案适用于配置信息中等的场景。"}]}]},{"type":"horizontalRule"}]}