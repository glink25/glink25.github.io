{"__ud_title":"JS中的组合与继承","__ud_tags":[],"__ud_update_time":1732152902975,"__ud_create_time":1732152882056,"__ud_draft":false,"type":"doc","content":[{"type":"heading","attrs":{"level":1},"content":[{"type":"text","text":"JS中的组合与继承"}]},{"type":"paragraph","content":[{"type":"text","text":"在前端开发中，有什么是继承可以做到而组合做不到的呢？"}]},{"type":"paragraph","content":[{"type":"text","text":"经典的EventTarget可以同时使用两种方式实现"}]},{"type":"codeBlock","attrs":{"language":"typescript"},"content":[{"type":"text","text":"// class\nexport class EventEmitter {\n    protected eventMap = new Map<string, Function[]>()\n    on(name: string, callback: (...args: any[]) => void) {\n        this.eventMap.set(name, [...this.eventMap.get(name) ?? [], callback])\n    }\n    off(name: string, callback: any) {\n        this.eventMap.set(name, (this.eventMap.get(name) ?? []).filter(c => c !== callback))\n    }\n    emit(name: string, ...args: any[]) {\n        this.eventMap.get(name)?.forEach((callback) => {\n            callback(...args)\n        })\n    }\n}\n\n// functional\nexport const createEventEmitter = () => {\n    const eventMap = new Map<string, Function[]>();\n    const on = (name: string, callback: (...args: any[]) => void) => {\n        eventMap.set(name, [...eventMap.get(name) ?? [], callback])\n    }\n    const off = (name: string, callback: any) => {\n        eventMap.set(name, (eventMap.get(name) ?? []).filter(c => c !== callback))\n    }\n    const emit = (name: string, ...args: any[]) => {\n        eventMap.get(name)?.forEach((callback) => {\n            callback(...args)\n        })\n    }\n\n    return {\n        on, off, emit\n    }\n}\n"}]},{"type":"paragraph","content":[{"type":"text","text":"看起来似乎都可以实现功能，只是换了种写法。"}]},{"type":"paragraph","content":[{"type":"text","text":"现在考虑一个父类，除了eventEmitter功能之外，还需要一些别的功能："}]},{"type":"codeBlock","attrs":{"language":"typescript"},"content":[{"type":"text","text":"// class\nexport class Parent extends EventEmitter {\n    someMethod() { }\n}\n\n// functional\nexport const createParent = () => {\n    const evenEmitter = createEventEmitter()\n    const someMethod = () => { }\n    return {\n        ...evenEmitter,\n        someMethod\n    }\n}\n"}]},{"type":"paragraph","content":[{"type":"text","text":"似乎依旧并无大碍，组合只是代码稍微多了一丢丢。"}]},{"type":"paragraph","content":[{"type":"text","text":"那么继续，现在父类需要暴露自己所有已注册的监听器名称"}]},{"type":"codeBlock","attrs":{"language":"typescript"},"content":[{"type":"text","text":"export class Parent extends EventEmitter {\n    someMethod() { }\n    get eventNames(){\n        return [...this.eventMap.keys()]\n    }\n}\n"}]},{"type":"paragraph","content":[{"type":"text","text":"于是，组合不适应的地方出现了。因为组合只有私有变量和公开变量（贴合class的说法），因此在多重嵌套下，要想用到内部某个函数的私有变量，只能从最底部开始，让其重新暴露出一个新的变量"}]},{"type":"codeBlock","attrs":{"language":"typescript"},"content":[{"type":"text","text":"export const createEventEmitter = () => {\n\t\t// ...\n    return {\n\t\t// 将eventMap作为公开变量暴露出来\n        on, off, emit, eventMap\n    }\n}\n\nexport const createParent = () => {\n    const { on, off, emit, eventMap } = createEventEmitter()\n    const someMethod = () => { }\n    return {\n        on, off, emit,\n        someMethod,\n        get eventNames() {\n            return [...eventMap.keys()]\n        }\n    }\n}\n"}]},{"type":"paragraph","content":[{"type":"text","text":"但是，这样的弊端就出现了，eventMap作为关键变量被危险地暴露了出来，现在这个组合不再安全，eventEMitter的eventMap可能会在其他地方被随意修改，监听器变得不再可靠。"}]},{"type":"paragraph","content":[{"type":"text","text":"这只是一些特意举出来的例子，事实上如何使用组合与继承是一门哲学，并非完全的谁一定好于谁。在大多数情况下，某个对象并不会一层层地基于另一个对象，使用组合不仅能良好地组织代码，帮助梳理各个对象间的关系，还可以提高代码阅读效率，毕竟，组合天然就具有多继承的特性："}]},{"type":"codeBlock","attrs":{"language":"typescript"},"content":[{"type":"text","text":"export const createAnimal = () => {\n    return {\n        eat: () => {\n            console.log('eat')\n        }\n    }\n}\n// 可以轻松实现Animal与EventMitter的“杂交”\nexport const createParent = () => {\n    const animal = createAnimal()\n    const eventEmitter = createEventEmitter()\n    const someMethod = () => { }\n    return {\n        ...eventEmitter,\n        ...animal,\n        someMethod\n    }\n}\n\n// Error, Javascript不支持多继承\nexport class Parent extends EventEmitter, Animal {\n    someMethod() { }\n    get eventNames() {\n        return [...this.eventMap.keys()]\n    }\n}\n"}]},{"type":"paragraph","content":[{"type":"text","text":"换句话说，组合更适合于平铺，适合于把多个解决方法合并起来；而继承适合嵌套，更多用在概念上的层层递进。当然，这里仅限于Javascript，因为Javascript天然没有多继承。"}]}]}