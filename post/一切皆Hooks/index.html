<!DOCTYPE html> <html lang="en"> <head><meta charset="UTF-8"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="URODELE"><meta name="msapplication-TileColor" content="#000000"><meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><meta name="description" content="Vue3 的composition api是一次巨大的更新，它几乎完全改变了Vue组件的编写模式，响应式体系更加方便与智能，同时与其他第三方库的配合也更加完美，因此我建议在所有的Vue3项目中，都只使用setup模式来编写组件。"><link rel="icon" href="/favicon.ico"><title>一切皆Hooks | Urodele</title><!-- Google Tag Manager --><script>
      (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({ "gtm.start": new Date().getTime(), event: "gtm.js" });
        var f = d.getElementsByTagName(s)[0],
          j = d.createElement(s),
          dl = l != "dataLayer" ? "&l=" + l : "";
        j.async = true;
        j.src = "https://www.googletagmanager.com/gtm.js?id=" + i + dl;
        f.parentNode.insertBefore(j, f);
      })(window, document, "script", "dataLayer", "GTM-WGC4G65Z");
    </script><!-- End Google Tag Manager --><link rel="stylesheet" href="/_astro/_page_.BGmKl0ar.css">
<style>._tabset_selm3_1 ._tab-panel_selm3_1{display:none}._tabset_selm3_1 ._tab-panels_selm3_4{display:flex}._tabset_selm3_1 input[data-tab-name=direct]{display:none}._tabset_selm3_1 input[data-tab-name=direct]:checked~._tab-panels_selm3_4 ._tab-panel_selm3_1[data-tab-name=direct]{display:block}._tabset_selm3_1 input[data-tab-name=direct]:checked~._tab-labels_selm3_13 label[data-tab-name=direct]{border-bottom:2px solid red}._tabset_selm3_1 input[data-tab-name=app]{display:none}._tabset_selm3_1 input[data-tab-name=app]:checked~._tab-panels_selm3_4 ._tab-panel_selm3_1[data-tab-name=app]{display:block}._tabset_selm3_1 input[data-tab-name=app]:checked~._tab-labels_selm3_13 label[data-tab-name=app]{border-bottom:2px solid red}
.outlines a[data-anchor-tag=H1]{margin-left:0}.outlines a[data-anchor-tag=H2]{margin-left:12px}.outlines a[data-anchor-tag=H3]{margin-left:24px}.outlines a[data-anchor-tag=H4]{margin-left:36px}.outlines a[data-anchor-tag=H5]{margin-left:48px}.outlines a[data-anchor-tag=H6]{margin-left:60px}
</style>
<link rel="stylesheet" href="/_astro/_page_.WL-iJiAT.css">
<link rel="stylesheet" href="/_astro/_id_.DDvAxtjx.css"><script type="module" src="/_astro/hoisted.vH3prKFL.js"></script></head> <body class="text-text bg-bg"> <!-- Google Tag Manager (noscript) --> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WGC4G65Z" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <!-- End Google Tag Manager (noscript) --> <header class="flex justify-between items-center p-2 gap-2 h-10"> <a href="/" class="text-button text-lg" aria-label="homepage"> <div class="i-ri:menu-4-fill"></div> </a> <div class="flex gap-2 items-center header-operations">   <div id="auth"></div> </div> </header>  <main> <div class="content"> <div class="w-full flex gap-2 pb-2"> <a href="/tag/Vue3" class="rounded hover:bg-gray-200 dark:hover:bg-modal px-3 py-1 cursor-pointer">
#Vue3 </a> </div> <div class="ud-root read-only flex-1"><h1 level="1" id="一切皆Hooks">一切皆Hooks</h1><p>Vue3 的composition api是一次巨大的更新，它几乎完全改变了Vue组件的编写模式，响应式体系更加方便与智能，同时与其他第三方库的配合也更加完美，因此我建议在所有的Vue3项目中，都只使用setup模式来编写组件。</p><p>即使只是简单地把Vue2组件中的选项式api换成setup模式，也能从这个过程中整理出许多可以复用的逻辑，这种逻辑抽离的快感会让你完全唾弃选项式API，且此后对于任何一处重复次数超过两次的代码你都会无可救药地想要把它拆成一个新的hooks，并且一遍遍地诅咒万恶的mixins被扫进历史的垃圾桶，这，就是全新的composition api。</p><p>如何给Hook下一个定义呢？其实官方并没有用hook这个说法，而是统称为composable，意为组合，把许多响应式变量组合起来并暴露给其他组件或者composable使用，就可以称为hook函数，而在Vue3中，几乎所有东西都可以使用hooks实现。</p><h1 level="1" id="组件即Hooks">组件即Hooks</h1><p>这很容易理解，因为setup模式下所有的响应式变量都可以被抽离到单独的文件中，即使是props也可以使用toRefs将其变为响应式变量导出。因此理论上，所有的组件都可以写成一个template.vue+一个useXXX.ts文件，不过这么做显然有点矫枉过正，在编写hook的过程中，尽量只抽离与props无关的变量，例如纯函数组件，就明显不需要写成hook形式。hook适用于表示纯粹的状态，例如一个撤销重做的记录栈，hook专注于给出值，而组件只负责展示和调用hook暴露出来的方法。如果你想对hook的创建和用法有一个深入的认知，建议看看这个项目 @vue/use，里面有着许许多多的hooks用法，多到令人发指。</p><h1 level="1" id="指令也可以是Hooks">指令也可以是Hooks</h1><p>得益于Vue提供了生命周期钩子函数，在大部分情况下，hook可以用来代替指令。</p><p>一直以来，编写Vue的自定义指令都有一个非常麻烦的地方，那就是如果需要在mount期间监听某个事件，并且希望在beforeUnmount的时候取消监听时，这个指令的写法会变的十分复杂：</p><div class="llt-code readonly"><div class="language">typescript</div><div class="wrapper"><pre><code class="language-typescript"><span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-attr" class="hljs-attr">clickOutside</span>: <span class="hljs-title,class_" class="hljs-title,class_">Directive</span>={
	<span class="hljs-attr" class="hljs-attr">mounted</span>:<span class="hljs-function" class="hljs-function">(<span class="hljs-params" class="hljs-params">el</span>) =&gt;</span> {
		<span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-title,function_" class="hljs-title,function_">fn</span> = (<span class="hljs-params" class="hljs-params">e</span>)=&gt;{
			<span class="hljs-comment" class="hljs-comment">// click outside</span>
		}
		<span class="hljs-variable,language_" class="hljs-variable,language_">window</span>.<span class="hljs-title,function_" class="hljs-title,function_">addEventListener</span>(<span class="hljs-string" class="hljs-string">&apos;click&apos;</span>, fn)
	},
	<span class="hljs-attr" class="hljs-attr">beforeUnmount</span>: <span class="hljs-function" class="hljs-function">()=&gt;</span> {
		<span class="hljs-comment" class="hljs-comment">// 没有办法直接在这里取消监听事件，必须通过外部变量或者dom元素来传递监听器</span>
		<span class="hljs-variable,language_" class="hljs-variable,language_">window</span>.<span class="hljs-title,function_" class="hljs-title,function_">removeListener</span>(<span class="hljs-string" class="hljs-string">&apos;click&apos;</span>, fn)
	}
}
</code></pre></div></div><p>但是如果使用hook来做就很方便：</p><div class="llt-code readonly"><div class="language">typescript</div><div class="wrapper"><pre><code class="language-typescript"><span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-title,function_" class="hljs-title,function_">useClickOutside</span> = (<span class="hljs-params" class="hljs-params"><span class="hljs-attr" class="hljs-attr">el</span>:<span class="hljs-title,class_" class="hljs-title,class_">Ref</span>&lt;<span class="hljs-title,class_" class="hljs-title,class_">HtmlElement</span>|<span class="hljs-literal" class="hljs-literal">undefined</span>&gt;</span>) =&gt; {
	<span class="hljs-title,function_" class="hljs-title,function_">onMounted</span>(<span class="hljs-function" class="hljs-function">()=&gt;</span>{
		<span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-title,function_" class="hljs-title,function_">fn</span>= (<span class="hljs-params" class="hljs-params"></span>) =&gt; {
			<span class="hljs-comment" class="hljs-comment">// click outside</span>
		};
		<span class="hljs-variable,language_" class="hljs-variable,language_">window</span>.<span class="hljs-title,function_" class="hljs-title,function_">addEventListener</span>(<span class="hljs-string" class="hljs-string">&apos;click&apos;</span>, fn);
		<span class="hljs-title,function_" class="hljs-title,function_">onBeforeUnmount</span>(<span class="hljs-function" class="hljs-function">()=&gt;</span>{
			<span class="hljs-variable,language_" class="hljs-variable,language_">window</span>.<span class="hljs-title,function_" class="hljs-title,function_">removeListener</span>(<span class="hljs-string" class="hljs-string">&apos;click&apos;</span>, fn)
		})
	})
}
</code></pre></div></div><p>得益于Vue3把生命周期做成了独立的钩子函数，使得组件的生命周期也能拆分成独立的逻辑</p><h1 level="1" id="Hooks--Stores">Hooks &gt; Stores</h1><p>使用pinia或者Vuex这样的第三方状态库也可以实现全局响应式变量的效果，不过对我而言，使用这些库的唯一好处是可以在开发时使用vue devtools实时看到和修改store里的state，其他方面，createStore完全可以被hook取代。hook作为一个单纯的函数，不需要在main.ts里引入文件，初始化也更简单，同样支持循环引用，并且，它还可以完全利用到Vue3响应式变量的大部分特性，例如readonly，对于typescript的支持也更友好：</p><div class="llt-code readonly"><div class="language">typescript</div><div class="wrapper"><pre><code class="language-typescript"><span class="hljs-comment" class="hljs-comment">// pinia</span>
<span class="hljs-keyword" class="hljs-keyword">const</span> store = <span class="hljs-title,function_" class="hljs-title,function_">createPinia</span>({
	<span class="hljs-attr" class="hljs-attr">state</span>:<span class="hljs-function" class="hljs-function">()=&gt;</span>({
		<span class="hljs-attr" class="hljs-attr">visible</span>:<span class="hljs-literal" class="hljs-literal">false</span>,
	}),
	<span class="hljs-attr" class="hljs-attr">actions</span>:{
		<span class="hljs-comment" class="hljs-comment">// 无法保证调用者只使用show来修改visible的值</span>
		<span class="hljs-title,function_" class="hljs-title,function_">show</span>(<span class="hljs-params" class="hljs-params"></span>){
			<span class="hljs-variable,language_" class="hljs-variable,language_">this</span>.<span class="hljs-property" class="hljs-property">visible</span> = <span class="hljs-literal" class="hljs-literal">false</span>;
		}
	},
})

<span class="hljs-comment" class="hljs-comment">// hooks</span>
<span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-title,function_" class="hljs-title,function_">useVisible</span> = (<span class="hljs-params" class="hljs-params"></span>)=&gt;{
	<span class="hljs-keyword" class="hljs-keyword">const</span> visible = <span class="hljs-title,function_" class="hljs-title,function_">ref</span>(<span class="hljs-literal" class="hljs-literal">false</span>)
	<span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-title,function_" class="hljs-title,function_">show</span> = (<span class="hljs-params" class="hljs-params"></span>)=&gt;{
		visible.<span class="hljs-property" class="hljs-property">value</span> = <span class="hljs-literal" class="hljs-literal">true</span>
	}
	<span class="hljs-keyword" class="hljs-keyword">return</span> {
		<span class="hljs-comment" class="hljs-comment">// 使用readonly确保暴露出的变量不会被意外修改</span>
		<span class="hljs-attr" class="hljs-attr">visible</span>: <span class="hljs-title,function_" class="hljs-title,function_">readonly</span>(visible),
		show
	}
}
</code></pre></div></div><p>store的另一个优点是它能与vue devtools做良好的集成，方便开发使用，不过在一些小项目中，使用自定义hooks也能完全满足需求。</p><p>需要注意的是，每一个store都是单例的，而hook只是一个普通的函数，所以如果要想实现全局hook，需要使用闭包或者直接在全局作用域导出，不过我并不推荐后者，因为那会导致意外的副作用和tree-shaking失效，并且在不支持顶级await的情况下，编写某些异步操作会变得比较丑陋。</p><div class="llt-code readonly"><div class="language">typescript</div><div class="wrapper"><pre><code class="language-typescript"><span class="hljs-comment" class="hljs-comment">// 使用闭包确保每次调用useVisible得到的变量为同一份</span>
<span class="hljs-keyword" class="hljs-keyword">export</span> <span class="hljs-keyword" class="hljs-keyword">const</span> useVisible = (<span class="hljs-function" class="hljs-function">()=&gt;</span>{
	<span class="hljs-keyword" class="hljs-keyword">const</span> visible = <span class="hljs-title,function_" class="hljs-title,function_">ref</span>(<span class="hljs-literal" class="hljs-literal">false</span>)
	<span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-title,function_" class="hljs-title,function_">show</span> = (<span class="hljs-params" class="hljs-params"></span>)=&gt;{
		visible.<span class="hljs-property" class="hljs-property">value</span> = <span class="hljs-literal" class="hljs-literal">true</span>
	}
	<span class="hljs-keyword" class="hljs-keyword">return</span> <span class="hljs-function" class="hljs-function">() =&gt;</span> {
		<span class="hljs-attr" class="hljs-attr">visible</span>: <span class="hljs-title,function_" class="hljs-title,function_">readonly</span>(visible),
		show
	}
})()

<span class="hljs-comment" class="hljs-comment">// 或者直接全局导出，不建议</span>
<span class="hljs-keyword" class="hljs-keyword">const</span> visible = <span class="hljs-title,function_" class="hljs-title,function_">ref</span>(<span class="hljs-literal" class="hljs-literal">false</span>)
<span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-title,function_" class="hljs-title,function_">show</span> = (<span class="hljs-params" class="hljs-params"></span>)=&gt;{
		visible.<span class="hljs-property" class="hljs-property">value</span> = <span class="hljs-literal" class="hljs-literal">true</span>
}
<span class="hljs-keyword" class="hljs-keyword">export</span> {
		<span class="hljs-attr" class="hljs-attr">visible</span>: <span class="hljs-title,function_" class="hljs-title,function_">readonly</span>(visible),
		show
	}
</code></pre></div></div><h1 level="1" id="不同于React-Hooks">不同于React Hooks</h1><p>由于我并没有太多使用React工程化的经验，因此我只能粗浅地说一下我的二者区别的理解。在我看来，React Hook是一套依托于React渲染管线而存在的状态抽象集合，它必须依赖于React存在，否则便会失去意义，失去“状态”，并且没有生命周期的概念；而Vue则更像是基于vue/reactivity 搭建了一套响应式变量体系，再基于这个体系建立了Vue的render系统，刚好与React相反。正如Vue的官方文档中写的那样，基于vue/reactivity，我们甚至可以重新写一套组件渲染系统。除此之外，我们还可以单独使用reactivity库，而不仅仅只用在界面渲染上，例如在node中搭配socket与浏览器同步信息等等，比起React，Vue的响应式变量有更广泛的使用场景。</p><script type="module">const injectHtml = (root, html) => {
  const iframe = document.createElement("iframe");
  const htmlContent = `<html><head></head><body>${html}</body></html>`;
  iframe.style.width = "100%";
  iframe.style.height = "100%";
  iframe.onload = () => {
    const doc = iframe.contentDocument || iframe.contentWindow?.document;
    if (!doc) {
      return;
    }
    doc.open();
    doc.write(htmlContent);
    doc.close();
  };
  root.replaceChildren(iframe);
}
  document.querySelectorAll('.playground')?.forEach(el=>{
    const html = el.getAttribute('data-html');
    if (html) {
      injectHtml(el,html);
    }
    const indicator = document.createElement("div");
    indicator.className = "indicator";
    const showCode = document.createElement("div");
    showCode.className = "show-code";
    showCode.innerText = "code";
    showCode.onclick = () => {
      el.parentElement.classList.remove("preview-only");
    };
    const showPreview = document.createElement("div");
    showPreview.className = "show-preview";
    showPreview.innerText = "preview";
    showPreview.onclick = () => {
      el.parentElement.classList.add("preview-only");
    };
    indicator.appendChild(showCode);
    indicator.appendChild(showPreview);
    el.parentElement.appendChild(indicator);
    if (window.screen.width < 768) {
      showPreview.click();
    }
  });</script></div> <div data-page-id="一切皆Hooks" class="navigator flex justify-between items-center mt-4 py-4"> <a href="/post/JS中的组合与继承" class="flex items-center gap-1 text-blue cursor-pointer flex-[45%]"> <div class="i-ri:arrow-left-double-line w-5 h-5 flex-shrink-0"></div> <div class="text-start">JS中的组合与继承</div> </a> <a href="/post/移动端网页避坑指南" class="flex items-center justify-end gap-1 text-blue cursor-pointer flex-[45%]"> <div class="text-end">移动端网页避坑指南</div> <div class="i-ri:arrow-right-double-line w-5 h-5 flex-shrink-0"></div> </a> </div> </div> <div class="outline-wrapper"></div> </main> <div class="giscus-container flex justify-center"> <div class="w-full max-w-[870px] mx-8"> <script src="https://giscus.app/client.js" data-repo="glink25/glink25.github.io" data-repo-id="R_kgDONTJ_KQ" data-category="Announcements" data-category-id="DIC_kwDONTJ_Kc4Ckrg6" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script> </div> </div> <div class="mt-8 w-full flex flex-col items-center group"> <ul class="max-w-[720px] flex justify-center gap-6 [&_li]:opacity-60 [&_li:hover]:opacity-100 border-t border-t-[4px] border-t-double pt-4"> <li> <a href="/tag">Tags</a> </li> <li> <a href="https://github.com/glink25" target="_blank">About</a> </li> <li class="relative" tabindex="-1"> <div class="cursor-pointer">Tools</div> </li> </ul> <div class="group-focus-within:flex hidden flex-col gap-2 p-2 items-center [&>*]:opacity-60 [&>*:hover]:opacity-100 [&>*:hover]:underline [&>*:hover:after]:content-[1]"> <a href="https://oncent.github.io" target="_blank">Oncent - 多人记账PWA，无需服务器</a> <a href="https://peek-transfer.github.io" target="_blank">Peek - 点对点快速传输文件</a> <a href="https://glink25.gitee.io" target="_blank">My Days - 倒数日</a> </div> </div> <footer class="flex justify-center"> <small class="w-full max-w-[720px] min-h-12 flex justify-center items-center opacity-60"> <a href="https://github.com/glink25" target="_blank">© Glink</a> </small> </footer> </body></html>