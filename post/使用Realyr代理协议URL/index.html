<!DOCTYPE html> <html lang="en"> <head><meta charset="UTF-8"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Link AI"><meta name="msapplication-TileColor" content="#000000"><meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><meta name="description" content="在前端开发中，我们经常遇到跨域、需要动态更换 API 代理或是在请求头中注入鉴权信息的需求。本文将介绍一种通过 Fetch 劫持 结合 自定义伪协议 的方案，实现一套优雅且灵活的代理中间件。"><link rel="icon" href="/favicon.ico"><!-- Google Tag Manager --><script>
      (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({ "gtm.start": new Date().getTime(), event: "gtm.js" });
        var f = d.getElementsByTagName(s)[0],
          j = d.createElement(s),
          dl = l != "dataLayer" ? "&l=" + l : "";
        j.async = true;
        j.src = "https://www.googletagmanager.com/gtm.js?id=" + i + dl;
        f.parentNode.insertBefore(j, f);
      })(window, document, "script", "dataLayer", "GTM-WGC4G65Z");
    </script><!-- End Google Tag Manager --><title>使用Relayr代理协议URL | Link AI</title><link rel="stylesheet" href="/_astro/_page_.BiKo2xiw.css">
<style>.outlines a[data-anchor-tag=H1]{margin-left:0}.outlines a[data-anchor-tag=H2]{margin-left:12px}.outlines a[data-anchor-tag=H3]{margin-left:24px}.outlines a[data-anchor-tag=H4]{margin-left:36px}.outlines a[data-anchor-tag=H5]{margin-left:48px}.outlines a[data-anchor-tag=H6]{margin-left:60px}
._tabset_selm3_1 ._tab-panel_selm3_1{display:none}._tabset_selm3_1 ._tab-panels_selm3_4{display:flex}._tabset_selm3_1 input[data-tab-name=direct]{display:none}._tabset_selm3_1 input[data-tab-name=direct]:checked~._tab-panels_selm3_4 ._tab-panel_selm3_1[data-tab-name=direct]{display:block}._tabset_selm3_1 input[data-tab-name=direct]:checked~._tab-labels_selm3_13 label[data-tab-name=direct]{border-bottom:2px solid red}._tabset_selm3_1 input[data-tab-name=app]{display:none}._tabset_selm3_1 input[data-tab-name=app]:checked~._tab-panels_selm3_4 ._tab-panel_selm3_1[data-tab-name=app]{display:block}._tabset_selm3_1 input[data-tab-name=app]:checked~._tab-labels_selm3_13 label[data-tab-name=app]{border-bottom:2px solid red}
</style>
<link rel="stylesheet" href="/_astro/_page_.BIc4xYU2.css">
<link rel="stylesheet" href="/_astro/_id_.snf5k5wG.css"><script type="module" src="/_astro/hoisted.DXwR34hd.js"></script></head> <body class="text-text bg-bg"> <!-- Google Tag Manager (noscript) --> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WGC4G65Z" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <!-- End Google Tag Manager (noscript) --> <header class="flex justify-between items-center p-2 gap-2 h-10"> <a href="/" class="text-button text-lg" aria-label="homepage"> <div class="i-ri:menu-4-fill"></div> </a> <div class="flex gap-2 items-center header-operations">   <div id="auth"></div> </div> </header>  <main> <div class="content"> <div class="w-full flex gap-2 pb-2">  <a href="/tag/Cent" class="rounded hover:bg-gray-200 dark:hover:bg-modal px-3 py-1 cursor-pointer">
#Cent </a> </div> <div class="ud-root read-only flex-1"><h1 level="1" id="使用Relayr代理协议URL">使用Relayr代理协议URL</h1><p>在前端开发中，我们经常遇到跨域、需要动态更换 API 代理或是在请求头中注入鉴权信息的需求。本文将介绍一种通过 <strong>Fetch 劫持</strong> 结合 <strong>自定义伪协议</strong> 的方案，实现一套优雅且灵活的代理中间件。</p><blockquote><p>在Cent中，所有允许输入自定义URL的地方都支持Relayr协议自定义代理，但是你需要自己实现一个支持该协议的后端服务，可以通过Cloudflare Workers或者Supabase Edge Function部署。</p></blockquote><h2 level="2" id="1-协议设计">1. 协议设计</h2><p>传统的 URL 传参容易受到特殊字符（如 JSON 中的引号、大括号）的影响，导致解析失败。我们采用 <strong>Base64 编码配置</strong> 的方案：</p><h3 level="3" id="协议格式">协议格式</h3><p><code>proxy://&lt;base64_config&gt;@&lt;target_path_suffix&gt;</code></p><ul><li><p><code>proxy://</code>: 协议头，用于中间件识别。</p></li><li><p><code>&lt;base64_config&gt;</code>: 包含代理服务器地址、目标基准地址、额外 Header 的 JSON 对象，并经过 Base64 编码。</p></li><li><p><code>@</code>: 分隔符。</p></li><li><p><code>&lt;target_path_suffix&gt;</code>: 具体的 API 路径后缀。</p></li></ul><h3 level="3" id="数据结构示例">数据结构示例</h3><p>编码前的 JSON 配置：</p><p>JSON</p><div class="llt-code readonly"><div class="language">json</div><div class="wrapper"><pre><code class="language-json"><span class="hljs-punctuation" class="hljs-punctuation">{</span>
  <span class="hljs-attr" class="hljs-attr">&quot;proxyUrl&quot;</span><span class="hljs-punctuation" class="hljs-punctuation">:</span> <span class="hljs-string" class="hljs-string">&quot;https://my-server.com/proxy&quot;</span><span class="hljs-punctuation" class="hljs-punctuation">,</span>
  <span class="hljs-attr" class="hljs-attr">&quot;targetBase&quot;</span><span class="hljs-punctuation" class="hljs-punctuation">:</span> <span class="hljs-string" class="hljs-string">&quot;https://api.openai.com&quot;</span><span class="hljs-punctuation" class="hljs-punctuation">,</span>
  <span class="hljs-attr" class="hljs-attr">&quot;headers&quot;</span><span class="hljs-punctuation" class="hljs-punctuation">:</span> <span class="hljs-punctuation" class="hljs-punctuation">{</span>
    <span class="hljs-attr" class="hljs-attr">&quot;x-proxy-key&quot;</span><span class="hljs-punctuation" class="hljs-punctuation">:</span> <span class="hljs-string" class="hljs-string">&quot;Bearer sk-123&quot;</span>
  <span class="hljs-punctuation" class="hljs-punctuation">}</span>
<span class="hljs-punctuation" class="hljs-punctuation">}</span>
</code></pre></div></div><hr><h2 level="2" id="2-前端中间件实现">2. 前端中间件实现</h2><p>基于你已有的 <code>registerProxy</code> 劫持框架，我们编写如下解析逻辑：</p><p>TypeScript</p><div class="llt-code readonly"><div class="language">javascript</div><div class="wrapper"><pre><code class="language-javascript"><span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-attr" class="hljs-attr">proxyMiddleware</span>: <span class="hljs-title,class_" class="hljs-title,class_">Handler</span> = <span class="hljs-title,function_" class="hljs-title,function_">async</span> (url, options, next) =&gt; {
    <span class="hljs-keyword" class="hljs-keyword">const</span> urlStr = url.<span class="hljs-title,function_" class="hljs-title,function_">toString</span>();

    <span class="hljs-comment" class="hljs-comment">// 1. 识别协议</span>
    <span class="hljs-keyword" class="hljs-keyword">if</span> (!urlStr.<span class="hljs-title,function_" class="hljs-title,function_">startsWith</span>(<span class="hljs-string" class="hljs-string">&apos;proxy://&apos;</span>)) {
        <span class="hljs-keyword" class="hljs-keyword">return</span> <span class="hljs-title,function_" class="hljs-title,function_">next</span>(url, options);
    }

    <span class="hljs-keyword" class="hljs-keyword">try</span> {
        <span class="hljs-comment" class="hljs-comment">// 2. 拆分 Base64 配置与路径后缀</span>
        <span class="hljs-keyword" class="hljs-keyword">const</span> mainPart = urlStr.<span class="hljs-title,function_" class="hljs-title,function_">slice</span>(<span class="hljs-number" class="hljs-number">8</span>); <span class="hljs-comment" class="hljs-comment">// 移除 &apos;proxy://&apos;</span>
        <span class="hljs-keyword" class="hljs-keyword">const</span> [configBase64, ...pathParts] = mainPart.<span class="hljs-title,function_" class="hljs-title,function_">split</span>(<span class="hljs-string" class="hljs-string">&apos;@&apos;</span>);
        <span class="hljs-keyword" class="hljs-keyword">const</span> targetPathSuffix = pathParts.<span class="hljs-title,function_" class="hljs-title,function_">join</span>(<span class="hljs-string" class="hljs-string">&apos;@&apos;</span>); <span class="hljs-comment" class="hljs-comment">// 防止路径中也带有 @</span>

        <span class="hljs-comment" class="hljs-comment">// 3. 解码并解析配置</span>
        <span class="hljs-keyword" class="hljs-keyword">const</span> configJson = <span class="hljs-title,class_" class="hljs-title,class_">JSON</span>.<span class="hljs-title,function_" class="hljs-title,function_">parse</span>(<span class="hljs-title,function_" class="hljs-title,function_">atob</span>(configBase64));
        <span class="hljs-keyword" class="hljs-keyword">const</span> { proxyUrl, targetBase, <span class="hljs-attr" class="hljs-attr">headers</span>: extraHeaders } = configJson;

        <span class="hljs-comment" class="hljs-comment">// 拼接最终目标地址</span>
        <span class="hljs-keyword" class="hljs-keyword">const</span> finalTargetUrl = <span class="hljs-string" class="hljs-string">`<span class="hljs-subst" class="hljs-subst">${targetBase}</span><span class="hljs-subst" class="hljs-subst">${targetPathSuffix}</span>`</span>;

        <span class="hljs-comment" class="hljs-comment">// 4. 转换请求参数</span>
        <span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-attr" class="hljs-attr">newOptions</span>: <span class="hljs-title,class_" class="hljs-title,class_">RequestInit</span> = {
            ...options,
            <span class="hljs-attr" class="hljs-attr">method</span>: <span class="hljs-string" class="hljs-string">&apos;POST&apos;</span>, <span class="hljs-comment" class="hljs-comment">// 代理请求统一转为 POST 以便在 Body 中携带 target</span>
            <span class="hljs-attr" class="hljs-attr">headers</span>: {
                ...options.<span class="hljs-property" class="hljs-property">headers</span>,
                ...extraHeaders,
                <span class="hljs-string" class="hljs-string">&apos;Content-Type&apos;</span>: <span class="hljs-string" class="hljs-string">&apos;application/json&apos;</span>
            },
            <span class="hljs-attr" class="hljs-attr">body</span>: <span class="hljs-title,class_" class="hljs-title,class_">JSON</span>.<span class="hljs-title,function_" class="hljs-title,function_">stringify</span>({
                <span class="hljs-attr" class="hljs-attr">target</span>: finalTargetUrl,
                <span class="hljs-attr" class="hljs-attr">payload</span>: options.<span class="hljs-property" class="hljs-property">body</span> ? 
                         (<span class="hljs-keyword" class="hljs-keyword">typeof</span> options.<span class="hljs-property" class="hljs-property">body</span> === <span class="hljs-string" class="hljs-string">&apos;string&apos;</span> ? <span class="hljs-title,class_" class="hljs-title,class_">JSON</span>.<span class="hljs-title,function_" class="hljs-title,function_">parse</span>(options.<span class="hljs-property" class="hljs-property">body</span>) : options.<span class="hljs-property" class="hljs-property">body</span>) 
                         : <span class="hljs-literal" class="hljs-literal">null</span>
            })
        };

        <span class="hljs-variable,language_" class="hljs-variable,language_">console</span>.<span class="hljs-title,function_" class="hljs-title,function_">log</span>(<span class="hljs-string" class="hljs-string">`[Proxy] Forwarding to: <span class="hljs-subst" class="hljs-subst">${finalTargetUrl}</span>`</span>);
        <span class="hljs-keyword" class="hljs-keyword">return</span> <span class="hljs-title,function_" class="hljs-title,function_">next</span>(proxyUrl, newOptions);
    } <span class="hljs-keyword" class="hljs-keyword">catch</span> (err) {
        <span class="hljs-variable,language_" class="hljs-variable,language_">console</span>.<span class="hljs-title,function_" class="hljs-title,function_">error</span>(<span class="hljs-string" class="hljs-string">&quot;[Proxy Error]&quot;</span>, err);
        <span class="hljs-keyword" class="hljs-keyword">return</span> <span class="hljs-title,function_" class="hljs-title,function_">next</span>(url, options);
    }
};
</code></pre></div></div><hr><h2 level="2" id="3-代理后端实现-Nodejs-示例">3. 代理后端实现 (Node.js 示例)</h2><p>后端代理服务器需要接收 <code>POST</code> 请求，解析其中的 <code>target</code> 字段，并携带请求头转发。</p><p>JavaScript</p><div class="llt-code readonly"><div class="language">javascript</div><div class="wrapper"><pre><code class="language-javascript"><span class="hljs-keyword" class="hljs-keyword">const</span> express = <span class="hljs-built_in" class="hljs-built_in">require</span>(<span class="hljs-string" class="hljs-string">&apos;express&apos;</span>);
<span class="hljs-keyword" class="hljs-keyword">const</span> axios = <span class="hljs-built_in" class="hljs-built_in">require</span>(<span class="hljs-string" class="hljs-string">&apos;axios&apos;</span>);
<span class="hljs-keyword" class="hljs-keyword">const</span> app = <span class="hljs-title,function_" class="hljs-title,function_">express</span>();

app.<span class="hljs-title,function_" class="hljs-title,function_">use</span>(express.<span class="hljs-title,function_" class="hljs-title,function_">json</span>());

app.<span class="hljs-title,function_" class="hljs-title,function_">post</span>(<span class="hljs-string" class="hljs-string">&apos;/proxy&apos;</span>, <span class="hljs-title,function_" class="hljs-title,function_">async</span> (req, res) =&gt; {
    <span class="hljs-keyword" class="hljs-keyword">const</span> { target, payload } = req.<span class="hljs-property" class="hljs-property">body</span>;
    
    <span class="hljs-comment" class="hljs-comment">// 获取前端注入的额外 Header (例如 x-proxy-key)</span>
    <span class="hljs-keyword" class="hljs-keyword">const</span> proxyHeaders = { ...req.<span class="hljs-property" class="hljs-property">headers</span> };
    <span class="hljs-comment" class="hljs-comment">// 移除宿主信息，防止目标服务器校验失败</span>
    <span class="hljs-keyword" class="hljs-keyword">delete</span> proxyHeaders.<span class="hljs-property" class="hljs-property">host</span>; 

    <span class="hljs-keyword" class="hljs-keyword">try</span> {
        <span class="hljs-variable,language_" class="hljs-variable,language_">console</span>.<span class="hljs-title,function_" class="hljs-title,function_">log</span>(<span class="hljs-string" class="hljs-string">`Forwarding request to: <span class="hljs-subst" class="hljs-subst">${target}</span>`</span>);
        
        <span class="hljs-keyword" class="hljs-keyword">const</span> response = <span class="hljs-keyword" class="hljs-keyword">await</span> <span class="hljs-title,function_" class="hljs-title,function_">axios</span>({
            <span class="hljs-attr" class="hljs-attr">method</span>: <span class="hljs-string" class="hljs-string">&apos;POST&apos;</span>, <span class="hljs-comment" class="hljs-comment">// 或根据逻辑透传原 method</span>
            <span class="hljs-attr" class="hljs-attr">url</span>: target,
            <span class="hljs-attr" class="hljs-attr">data</span>: payload,
            <span class="hljs-attr" class="hljs-attr">headers</span>: proxyHeaders,
            <span class="hljs-attr" class="hljs-attr">timeout</span>: <span class="hljs-number" class="hljs-number">10000</span>
        });

        res.<span class="hljs-title,function_" class="hljs-title,function_">status</span>(response.<span class="hljs-property" class="hljs-property">status</span>).<span class="hljs-title,function_" class="hljs-title,function_">send</span>(response.<span class="hljs-property" class="hljs-property">data</span>);
    } <span class="hljs-keyword" class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword" class="hljs-keyword">const</span> status = error.<span class="hljs-property" class="hljs-property">response</span> ? error.<span class="hljs-property" class="hljs-property">response</span>.<span class="hljs-property" class="hljs-property">status</span> : <span class="hljs-number" class="hljs-number">500</span>;
        res.<span class="hljs-title,function_" class="hljs-title,function_">status</span>(status).<span class="hljs-title,function_" class="hljs-title,function_">send</span>(error.<span class="hljs-property" class="hljs-property">message</span>);
    }
});

app.<span class="hljs-title,function_" class="hljs-title,function_">listen</span>(<span class="hljs-number" class="hljs-number">3000</span>, <span class="hljs-function" class="hljs-function">() =&gt;</span> <span class="hljs-variable,language_" class="hljs-variable,language_">console</span>.<span class="hljs-title,function_" class="hljs-title,function_">log</span>(<span class="hljs-string" class="hljs-string">&apos;Proxy Server running on port 3000&apos;</span>));
</code></pre></div></div><hr><h2 level="2" id="4-如何使用">4. 如何使用</h2><p>在业务代码中，你可以通过工具函数生成这个复合 URL：</p><h3 level="3" id="生成器工具">生成器工具</h3><p>JavaScript</p><div class="llt-code readonly"><div class="language">javascript</div><div class="wrapper"><pre><code class="language-javascript"><span class="hljs-keyword" class="hljs-keyword">function</span> <span class="hljs-title,function_" class="hljs-title,function_">createProxyUrl</span>(<span class="hljs-params" class="hljs-params">config, apiPath</span>) {
    <span class="hljs-keyword" class="hljs-keyword">const</span> base64 = <span class="hljs-title,function_" class="hljs-title,function_">btoa</span>(<span class="hljs-title,class_" class="hljs-title,class_">JSON</span>.<span class="hljs-title,function_" class="hljs-title,function_">stringify</span>(config));
    <span class="hljs-keyword" class="hljs-keyword">return</span> <span class="hljs-string" class="hljs-string">`proxy://<span class="hljs-subst" class="hljs-subst">${base64}</span>@<span class="hljs-subst" class="hljs-subst">${apiPath}</span>`</span>;
}
</code></pre></div></div><h3 level="3" id="发起请求">发起请求</h3><p>JavaScript</p><div class="llt-code readonly"><div class="language">javascript</div><div class="wrapper"><pre><code class="language-javascript"><span class="hljs-keyword" class="hljs-keyword">const</span> config = {
    <span class="hljs-attr" class="hljs-attr">proxyUrl</span>: <span class="hljs-string" class="hljs-string">&quot;http://localhost:3000/proxy&quot;</span>,
    <span class="hljs-attr" class="hljs-attr">targetBase</span>: <span class="hljs-string" class="hljs-string">&quot;https://api.openai.com&quot;</span>,
    <span class="hljs-attr" class="hljs-attr">headers</span>: { <span class="hljs-string" class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string" class="hljs-string">&quot;Bearer TOKEN&quot;</span> }
};

<span class="hljs-comment" class="hljs-comment">// 实际请求地址：proxy://ey...@{config}@/v1/chat/completions</span>
<span class="hljs-title,function_" class="hljs-title,function_">fetch</span>(<span class="hljs-title,function_" class="hljs-title,function_">createProxyUrl</span>(config, <span class="hljs-string" class="hljs-string">&apos;/v1/chat/completions&apos;</span>), {
    <span class="hljs-attr" class="hljs-attr">method</span>: <span class="hljs-string" class="hljs-string">&apos;POST&apos;</span>,
    <span class="hljs-attr" class="hljs-attr">body</span>: <span class="hljs-title,class_" class="hljs-title,class_">JSON</span>.<span class="hljs-title,function_" class="hljs-title,function_">stringify</span>({ <span class="hljs-attr" class="hljs-attr">model</span>: <span class="hljs-string" class="hljs-string">&apos;gpt-3.5-turbo&apos;</span> })
});
</code></pre></div></div><hr><h2 level="2" id="5-总结">5. 总结</h2><p>该方案的优势在于：</p><ol><li><p><strong>高度封装</strong>：业务代码无需关心代理服务器的具体实现。</p></li><li><p><strong>兼容性强</strong>：Base64 避免了 URL 特殊字符带来的解析噩梦。</p></li><li><p><strong>动态性</strong>：可以随时在前端通过修改 <code>config</code> 来切换不同的代理节点或目标 API。</p></li></ol><blockquote><p><strong>注意</strong>：由于 Base64 编码会增加字符串体积，且 URL 长度在不同浏览器中有限制（如 Chrome 限制为 2MB），本方案适用于配置信息中等的场景。</p></blockquote><hr><script type="module">const injectHtml = (root, html) => {
  const iframe = document.createElement("iframe");
  const htmlContent = `<html><head></head><body>${html}</body></html>`;
  iframe.style.width = "100%";
  iframe.style.height = "100%";
  iframe.onload = () => {
    const doc = iframe.contentDocument || iframe.contentWindow?.document;
    if (!doc) {
      return;
    }
    doc.open();
    doc.write(htmlContent);
    doc.close();
  };
  root.replaceChildren(iframe);
}
  document.querySelectorAll('.playground')?.forEach(el=>{
    const html = el.getAttribute('data-html');
    if (html) {
      injectHtml(el,html);
    }
    const indicator = document.createElement("div");
    indicator.className = "indicator";
    const showCode = document.createElement("div");
    showCode.className = "show-code";
    showCode.innerText = "code";
    showCode.onclick = () => {
      el.parentElement.classList.remove("preview-only");
    };
    const showPreview = document.createElement("div");
    showPreview.className = "show-preview";
    showPreview.innerText = "preview";
    showPreview.onclick = () => {
      el.parentElement.classList.add("preview-only");
    };
    indicator.appendChild(showCode);
    indicator.appendChild(showPreview);
    el.parentElement.appendChild(indicator);
    if (window.screen.width < 768) {
      showPreview.click();
    }
  });</script></div> <div data-page-id="使用Realyr代理协议URL" class="navigator flex justify-between items-center mt-4 py-4"> <a href="/post/通过Relayr快捷记账" class="flex items-center gap-1 text-blue cursor-pointer flex-[45%]"> <div class="i-ri:arrow-left-double-line w-5 h-5 flex-shrink-0"></div> <div class="text-start">通过Relayr快捷记账</div> </a> <div></div> </div> </div> <div class="outline-wrapper"></div> </main> <div class="giscus-container flex justify-center"> <div class="w-full max-w-[870px] mx-8"> <script src="https://giscus.app/client.js" data-repo="glink25/glink25.github.io" data-repo-id="R_kgDONTJ_KQ" data-category="Announcements" data-category-id="DIC_kwDONTJ_Kc4Ckrg6" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script> </div> </div> <div class="mt-8 w-full flex flex-col items-center group"> <ul class="max-w-[720px] flex justify-center gap-6 [&_li]:opacity-60 [&_li:hover]:opacity-100 border-t border-t-[4px] border-t-double pt-4"> <li> <a href="/tag">Tags</a> </li> <li> <a href="https://github.com/glink25" target="_blank">About</a> </li> <li class="relative" tabindex="-1"> <div class="cursor-pointer">Tools</div> </li> </ul> <div class="group-focus-within:flex hidden flex-col gap-2 p-2 items-center [&>*]:opacity-60 [&>*:hover]:opacity-100 [&>*:hover]:underline [&>*:hover:after]:content-[1]"> <a href="https://oncent.github.io" target="_blank">Oncent - 多人记账PWA，无需服务器</a> <a href="https://peek-transfer.github.io" target="_blank">Peek - 点对点快速传输文件</a> <a href="https://glink25.gitee.io" target="_blank">My Days - 倒数日</a> </div> </div> <footer class="flex justify-center"> <small class="w-full max-w-[720px] min-h-12 flex justify-center items-center opacity-60"> <a href="https://github.com/glink25" target="_blank">© Glink</a> </small> </footer> </body></html>