<!DOCTYPE html> <html lang="en"> <head><meta charset="UTF-8"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="URODELE"><meta name="msapplication-TileColor" content="#000000"><meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><meta name="description" content="在我看来，vue3和vue2最大的区别就是响应式的思考方式的改变，在vue2中，响应式是渲染框架的一部分，你没办法单独地创建一个响应式状态然后复用它，只能用mixin把状态像配置文件那样隔离出来，再用在其他组件当中，响应式也只在组件中生效，这使得一套业务逻辑很难在vue中复用。如果你想要构建组件库，在vue2中最好的方式是构建一个大而全的组件，然后提供数量繁多的props给开发者自定义，而不是提供细粒度的单个组件让开发者自己组装，因为组装需要的逻辑一旦涉及到组件状态就会无法抽离，导致许多重复又无意义的封装。"><link rel="icon" href="/favicon.ico"><title>2022年了，如何写出优雅的vue3组件 | Urodele</title><!-- Google Tag Manager --><script>
      (function (w, d, s, l, i) {
        w[l] = w[l] || [];
        w[l].push({ "gtm.start": new Date().getTime(), event: "gtm.js" });
        var f = d.getElementsByTagName(s)[0],
          j = d.createElement(s),
          dl = l != "dataLayer" ? "&l=" + l : "";
        j.async = true;
        j.src = "https://www.googletagmanager.com/gtm.js?id=" + i + dl;
        f.parentNode.insertBefore(j, f);
      })(window, document, "script", "dataLayer", "GTM-WGC4G65Z");
    </script><!-- End Google Tag Manager --><link rel="stylesheet" href="/_astro/_page_.8T9hx2lF.css">
<style>._tabset_selm3_1 ._tab-panel_selm3_1{display:none}._tabset_selm3_1 ._tab-panels_selm3_4{display:flex}._tabset_selm3_1 input[data-tab-name=direct]{display:none}._tabset_selm3_1 input[data-tab-name=direct]:checked~._tab-panels_selm3_4 ._tab-panel_selm3_1[data-tab-name=direct]{display:block}._tabset_selm3_1 input[data-tab-name=direct]:checked~._tab-labels_selm3_13 label[data-tab-name=direct]{border-bottom:2px solid red}._tabset_selm3_1 input[data-tab-name=app]{display:none}._tabset_selm3_1 input[data-tab-name=app]:checked~._tab-panels_selm3_4 ._tab-panel_selm3_1[data-tab-name=app]{display:block}._tabset_selm3_1 input[data-tab-name=app]:checked~._tab-labels_selm3_13 label[data-tab-name=app]{border-bottom:2px solid red}
.outlines a[data-anchor-tag=H1]{margin-left:0}.outlines a[data-anchor-tag=H2]{margin-left:12px}.outlines a[data-anchor-tag=H3]{margin-left:24px}.outlines a[data-anchor-tag=H4]{margin-left:36px}.outlines a[data-anchor-tag=H5]{margin-left:48px}.outlines a[data-anchor-tag=H6]{margin-left:60px}
</style>
<link rel="stylesheet" href="/_astro/_page_.BIc4xYU2.css">
<link rel="stylesheet" href="/_astro/_id_.CRvXThkN.css"><script type="module" src="/_astro/hoisted.DCa5FXkN.js"></script></head> <body class="text-text bg-bg"> <!-- Google Tag Manager (noscript) --> <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WGC4G65Z" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript> <!-- End Google Tag Manager (noscript) --> <header class="flex justify-between items-center p-2 gap-2 h-10"> <a href="/" class="text-button text-lg" aria-label="homepage"> <div class="i-ri:menu-4-fill"></div> </a> <div class="flex gap-2 items-center header-operations">   <div id="auth"></div> </div> </header>  <main> <div class="content"> <div class="w-full flex gap-2 pb-2"> <a href="/tag/Vue3" class="rounded hover:bg-gray-200 dark:hover:bg-modal px-3 py-1 cursor-pointer">
#Vue3 </a> </div> <div class="ud-root read-only flex-1"><h1 level="1" id="2022年了如何写出优雅的vue3组件">2022年了，如何写出优雅的vue3组件</h1><h2 level="2" id="拥抱Setup">拥抱Setup</h2><p>在我看来，vue3和vue2最大的区别就是响应式的思考方式的改变，在vue2中，响应式是渲染框架的一部分，你没办法单独地创建一个响应式状态然后复用它，只能用mixin把状态像配置文件那样隔离出来，再用在其他组件当中，响应式也只在组件中生效，这使得一套业务逻辑很难在vue中复用。如果你想要构建组件库，在vue2中最好的方式是构建一个大而全的组件，然后提供数量繁多的props给开发者自定义，而不是提供细粒度的单个组件让开发者自己组装，因为组装需要的逻辑一旦涉及到组件状态就会无法抽离，导致许多重复又无意义的封装。</p><p>而在vue3中，响应式与组件渲染被彻底分离，并且与React hooks完全不同，响应式式真正的全局响应，而非只有在React或者Vue组件内使用才表现出响应性，例如computed和watch完全可以用在一个没有任何vue文件的项目中，而非依赖于组件框架。这也意味着在vue3中，渲染引擎成为了响应式的应用，Vue3的重新渲染是通过在响应式提供的监听变化的能力实现的，甚至我们可以自己写一个简单的渲染函数，例如</p><div class="llt-code readonly"><div class="language">typescript</div><div class="wrapper"><pre><code class="language-typescript">cons render = <span class="hljs-function" class="hljs-function">(<span class="hljs-params" class="hljs-params"><span class="hljs-attr" class="hljs-attr">state</span>:<span class="hljs-title,class_" class="hljs-title,class_">Ref</span>&lt;<span class="hljs-built_in" class="hljs-built_in">string</span>&gt;</span>)=&gt;</span>{
    <span class="hljs-keyword" class="hljs-keyword">const</span> html=<span class="hljs-string" class="hljs-string">`&lt;div&gt;<span class="hljs-subst" class="hljs-subst">${state.value}</span>&lt;/div&gt;`</span>
    <span class="hljs-title,function_" class="hljs-title,function_">watchEffect</span>(<span class="hljs-function" class="hljs-function">()=&gt;</span>{
        <span class="hljs-variable,language_" class="hljs-variable,language_">document</span>.<span class="hljs-property" class="hljs-property">body</span>.<span class="hljs-property" class="hljs-property">innerHTML</span>=html
    })
}
</code></pre></div></div><p>所以在vue3中，我更愿意去使用细粒度更小的组件，任何通过各式各样的useXXX hooks函数把它们组装起来，对响应式变量进行操作，而不是沿用vue2时代臃肿复杂的方式，对着this不停地放入和调用不知道是谁放进去的属性和函数。所以在实际体验方面，vue2和vue3项目看起最大的区别，除了每个vue文件都使用了setup模式来编写，每个vue文件的行数都少了许多之外，就是那个新增的hooks文件夹，里面放着从原本vue文件里抽离出来的各式各样封装好的逻辑，只需要维护这个hooks文件夹，就能维护好项目核心的业务逻辑。</p><p>为了达到这样的目的，setup模式，或者说composition api是必需的，如果在vue3中继续使用options api，那你也将与这些唾手可得的优势失之交臂。</p><h2 level="2" id="如无必要勿增指令">如无必要，勿增指令</h2><p>当我们不可避免地需要去手动操作dom的时候，vue2时的第一反应就是使用自定义指令，但在我看来，这个功能在有了composition api之后已经可以被完全代替了，在有了<code>ref</code> <code>onMounted</code>这些专门用来处理生命周期的函数和钩子之后，我们不再需要写自定义指令也能把dom操作拆分出来，事实上<code>vueuse</code>已经有例如<code>useClickOutside</code> <code>onLongpress</code>等和指令功能完全一致的替换hokk了，并且在类型支持方面比指令更为友好</p><h2 level="2" id="实例---MessageBox组件">实例 - MessageBox组件</h2><p>在vue2时代，我最喜欢element-ui组件库的一个功能，就是ElMessageBox，因为只需要在代码中简单地引入，然后调用对应的<code>this.$alert</code>或者<code>this.$confirm</code>等方法，就可以简单快速地在页面上弹出一条提示，不需要引入其他的组件，也不需要写一堆data用来绑定组件参数，然后把乱七八糟的visible啊title啊之类的传进去，甚至还可以设置基于Promise的回调，整个过程就像调用浏览器的原生api<code>confirm</code>或者<code>alert</code>一样简单，于是在我编写自己的第一个组件库的时候，我就想把这种方法用到自己的项目中，于是我去了解了相关的源码，element是这样实现的</p><div class="llt-code readonly"><div class="language">javascript</div><div class="wrapper"><pre><code class="language-javascript"><span class="hljs-comment" class="hljs-comment">// todo</span>
</code></pre></div></div><p>element-ui巧妙地使用了Vue2提供的plugin接口，通过设置全局属性在代码中注入显示message的方法，而方便地提供了弹出消息提示的功能。尽管用起来的很方便，但是背后的实现却不怎么优雅，它脱离了Vue自身的组件渲染机制，通过手动渲染vnode并挂载到body的方式来创建MessageBox的DOM，尽管完美地实现了功能，但还是存在了许多限制，例如无法方便地自定义message的样式，如果想要展示复杂的消息，只能通过传入html字符vnode来渲染自定义内容，传入HTML时不仅要考虑XSS攻击，还要手写一堆HTML模板，至于传入vnode，麻烦程度比起HTML只多不少，那还不如自己写一遍Dialog组件来的快了；同样也无法享受到Vue自带的css scope功能，如果只想改变当前组件内展示的Message样式，就只能在调用方法时传入customClass参数，然后在全局作用的css里小心翼翼地编写样式。在交互简单的模板类项目中，这样的方式无伤大雅，但一旦涉及到了复杂的交互逻辑，就不可避免地要去重新封装一遍。</p><p>在vue2时代，这样的方式可以说是带着镣铐跳舞，因为所有的响应式状态传递必须依托于vue的上下文，让我们无法脱离组件去编写单纯的业务逻辑。但是到了vue3时代的element plus，它的MessageBox还是基于相同的逻辑，为了保证迁移的一致性，即使vue3提供了vue/reactivity能力使得组件外编写响应状态成为可能，但是依旧没有解决上面存在的问题。</p><p>那么有方法可以鱼和熊掌兼得吗？得益于vue/reactivity，这个答案是肯定的</p><p>从送我们的需求触发，我们希望这个完美的MessageBox组件应该是这么用的</p><div class="llt-code readonly"><div class="language">vue</div><div class="wrapper"><pre><code class="language-vue"><span class="xml" class="xml"><span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">other-components</span> /&gt;</span>
    <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">perfect-message-box</span> <span class="hljs-attr" class="hljs-attr">:controller</span>=<span class="hljs-string" class="hljs-string">&quot;controller&quot;</span> &gt;</span>
        <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">custom-component</span> /&gt;</span>
    <span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">perfect-message-box</span>&gt;</span>
<span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">script</span> <span class="hljs-attr" class="hljs-attr">lang</span>=<span class="hljs-string" class="hljs-string">&quot;ts&quot;</span> <span class="hljs-attr" class="hljs-attr">setup</span>&gt;</span><span class="javascript" class="javascript">
<span class="hljs-keyword" class="hljs-keyword">import</span> { useMessageBox, <span class="hljs-title,class_" class="hljs-title,class_">PerfectMessageBox</span> } <span class="hljs-keyword" class="hljs-keyword">from</span> <span class="hljs-string" class="hljs-string">&quot;perfect-message-box&quot;</span>
<span class="hljs-keyword" class="hljs-keyword">const</span> { confirm, controller } = <span class="hljs-title,function_" class="hljs-title,function_">useMessageBox</span>();

<span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-title,function_" class="hljs-title,function_">toDoSomething</span> = <span class="hljs-keyword" class="hljs-keyword">async</span> (<span class="hljs-params" class="hljs-params"></span>)=&gt;{
    <span class="hljs-keyword" class="hljs-keyword">await</span> <span class="hljs-title,function_" class="hljs-title,function_">confirm</span>(<span class="hljs-string" class="hljs-string">&apos;Are you sure?&apos;</span>);
    <span class="hljs-title,function_" class="hljs-title,function_">doSomthing</span>();
}
</span><span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">script</span>&gt;</span>
</span></code></pre></div></div><p>**注意所有的vue3代码都是使用setup模式来写的，因为我实在无法理解有了setup为什么还要去写options</p><p>通过这种方式，我们可以做到了： 1，支持以slots方式传入自定义内容，契合vue的使用方式。 2，按需引入，如果某个懒加载的路由完全没有使用到MessageBox，那么在加载页面的时候就完全不会包括相关的代码。 3，依旧支持Promise调用，函数式的使用方式令人精神愉悦（划掉）。</p><p>这样的方式看起来十分符合我们的需求，那么我们如何才能做到呢？ conroller的实现是重点，它连接了confirm函数和组件的状态，使得调用confirm函数时传入的参数能够被渲染到组件之中，我们可以先从基础的MessageBox组件出发，看看controller需要提供哪些能力，一个简单的MessageBox demo如下：</p><div class="llt-code readonly"><div class="language">vue</div><div class="wrapper"><pre><code class="language-vue"><span class="xml" class="xml"><span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">teleport</span> <span class="hljs-attr" class="hljs-attr">v-if</span>=<span class="hljs-string" class="hljs-string">&quot;visible&quot;</span> <span class="hljs-attr" class="hljs-attr">:to</span>=<span class="hljs-string" class="hljs-string">&quot;body&quot;</span>&gt;</span>
        <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">div</span> <span class="hljs-attr" class="hljs-attr">class</span>=<span class="hljs-string" class="hljs-string">&quot;message-box&quot;</span>&gt;</span>
            <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">slot</span>&gt;</span>
                <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">div</span>&gt;</span>{{title}}<span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">slot</span>&gt;</span>
            <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">button</span> @<span class="hljs-attr" class="hljs-attr">click</span>=<span class="hljs-string" class="hljs-string">&quot;()=&gt;{$emit(&apos;update:visible&apos;,false);$emit(&apos;confirm&apos;)}&quot;</span>&gt;</span>confirm<span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">button</span> @<span class="hljs-attr" class="hljs-attr">click</span>=<span class="hljs-string" class="hljs-string">&quot;()=&gt;{$emit(&apos;update:visible&apos;,false);$emit(&apos;cancel&apos;)}&quot;</span>&gt;</span>cancel<span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">teleport</span>&gt;</span>
<span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">script</span> <span class="hljs-attr" class="hljs-attr">lang</span>=<span class="hljs-string" class="hljs-string">&quot;ts&quot;</span> <span class="hljs-attr" class="hljs-attr">setup</span>&gt;</span><span class="javascript" class="javascript">
defineProps&lt;{
    <span class="hljs-attr" class="hljs-attr">visible</span>: boolean;
    <span class="hljs-attr" class="hljs-attr">title</span>: string;
}&gt;()

defineEmit&lt;{
    (<span class="hljs-attr" class="hljs-attr">name</span>:<span class="hljs-string" class="hljs-string">&quot;update:visible&quot;</span>, <span class="hljs-attr" class="hljs-attr">value</span>: boolean):<span class="hljs-keyword" class="hljs-keyword">void</span>;
    (<span class="hljs-attr" class="hljs-attr">name</span>:<span class="hljs-string" class="hljs-string">&quot;confirm&quot;</span>):<span class="hljs-keyword" class="hljs-keyword">void</span>;
    (<span class="hljs-attr" class="hljs-attr">name</span>:<span class="hljs-string" class="hljs-string">&quot;cancel&quot;</span>):<span class="hljs-keyword" class="hljs-keyword">void</span>;
}&gt;()
</span><span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">script</span>&gt;</span>
</span></code></pre></div></div><p>可以看出，在这里MessageBox是靠Vue的事件来传递用户是否点击了确认或者取消，同时根据父组件传入的visible值来展示或者隐藏自身，那么controller就需要模仿这种事件机制，因为Vue的事件是无法在组件外使用的，可以写出这样的一个controller：</p><div class="llt-code readonly"><div class="language">typescript</div><div class="wrapper"><pre><code class="language-typescript"><span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-title,function_" class="hljs-title,function_">useMessageBox</span>=(<span class="hljs-params" class="hljs-params"></span>)=&gt;{
    <span class="hljs-keyword" class="hljs-keyword">const</span> controller = <span class="hljs-title,function_" class="hljs-title,function_">ref</span>({
        <span class="hljs-attr" class="hljs-attr">visible</span>: <span class="hljs-literal" class="hljs-literal">false</span>,
        <span class="hljs-attr" class="hljs-attr">title</span>:<span class="hljs-string" class="hljs-string">&apos;&apos;</span>,
        <span class="hljs-attr" class="hljs-attr">confirm</span>: <span class="hljs-function" class="hljs-function">()=&gt;</span><span class="hljs-literal" class="hljs-literal">undefined</span>,
        <span class="hljs-attr" class="hljs-attr">cancel</span>: <span class="hljs-function" class="hljs-function">()=&gt;</span><span class="hljs-literal" class="hljs-literal">undefined</span>,
    })
    <span class="hljs-keyword" class="hljs-keyword">const</span> <span class="hljs-title,function_" class="hljs-title,function_">show</span>=(<span class="hljs-params" class="hljs-params"><span class="hljs-attr" class="hljs-attr">title</span>:<span class="hljs-built_in" class="hljs-built_in">string</span></span>)=&gt;<span class="hljs-title,class_" class="hljs-title,class_">Promise</span>&lt;<span class="hljs-built_in" class="hljs-built_in">void</span>&gt;(<span class="hljs-function" class="hljs-function">(<span class="hljs-params" class="hljs-params">resolve,reject</span>)=&gt;</span>{
        controller.<span class="hljs-property" class="hljs-property">value</span>={
            title,
            <span class="hljs-attr" class="hljs-attr">visible</span>:<span class="hljs-literal" class="hljs-literal">true</span>,
            <span class="hljs-attr" class="hljs-attr">confirm</span>:<span class="hljs-function" class="hljs-function">()=&gt;</span>{
                controller.<span class="hljs-property" class="hljs-property">value</span> = { ...controller.<span class="hljs-property" class="hljs-property">value</span>, <span class="hljs-attr" class="hljs-attr">visible</span>: <span class="hljs-literal" class="hljs-literal">false</span> };
                <span class="hljs-title,function_" class="hljs-title,function_">resolve</span>()
            },
            <span class="hljs-attr" class="hljs-attr">cancel</span>:<span class="hljs-function" class="hljs-function">()=&gt;</span>{
                controller.<span class="hljs-property" class="hljs-property">value</span> = { ...controller.<span class="hljs-property" class="hljs-property">value</span>, <span class="hljs-attr" class="hljs-attr">visible</span>: <span class="hljs-literal" class="hljs-literal">false</span> };
                <span class="hljs-title,function_" class="hljs-title,function_">reject</span>()
            }
        }
    })
    <span class="hljs-keyword" class="hljs-keyword">return</span> {
        show, controller
    }
}
</code></pre></div></div><p>同时将MessageBox组件修改成这样：</p><div class="llt-code readonly"><div class="language">vue</div><div class="wrapper"><pre><code class="language-vue"><span class="xml" class="xml"><span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">teleport</span> <span class="hljs-attr" class="hljs-attr">v-if</span>=<span class="hljs-string" class="hljs-string">&quot;visible&quot;</span> <span class="hljs-attr" class="hljs-attr">:to</span>=<span class="hljs-string" class="hljs-string">&quot;body&quot;</span>&gt;</span>
        <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">div</span> <span class="hljs-attr" class="hljs-attr">class</span>=<span class="hljs-string" class="hljs-string">&quot;message-box&quot;</span>&gt;</span>
            <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">slot</span>&gt;</span>
                <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">div</span>&gt;</span>{{controller.title}}<span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">slot</span>&gt;</span>
            <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">button</span> @<span class="hljs-attr" class="hljs-attr">click</span>=<span class="hljs-string" class="hljs-string">&quot;controller.confirm()&quot;</span>&gt;</span>confirm<span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">button</span> @<span class="hljs-attr" class="hljs-attr">click</span>=<span class="hljs-string" class="hljs-string">&quot;controller.cancel()&quot;</span>&gt;</span>cancel<span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">teleport</span>&gt;</span>
<span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">script</span> <span class="hljs-attr" class="hljs-attr">lang</span>=<span class="hljs-string" class="hljs-string">&quot;ts&quot;</span> <span class="hljs-attr" class="hljs-attr">setup</span>&gt;</span>
defineProps&lt;{
    controller: Controller
}&gt;()
<span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">script</span>&gt;</span>
</span></code></pre></div></div><p>通过巧妙地设置和改变controller的值，使得组件可以不通过props来获取参数并传递相应的事件，这是不是像极了Vuex或者其他类似的状态管理工具的思路？不同的是，这里我们没有依靠任何第三方状态管理框架，仅凭vue/reactivity的能力就办到了，这也侧面说明某种意义上全局的状态管理能力是可以被vue/reactivity取代的。而在这个实例中，我们简单地通过响应式状态的传递实现了组件props和父组件的解耦，子组件可以不再仅靠声明式的props来渲染内容，父组件也有了更多调用子组件能力的方式，完美实现了原版ElMessageBox的功能，并且与Vue的特性完美结合，不再有奇奇怪怪的hack。</p><p>它还有许多衍生用法，例如导出一个<code>useGlobalConfirm</code>方法，并在App.vue根组件下插入MessageBox，使得所有组件或者函数在使用MessageBox时共用同一个实例，完美复刻原版ElMessageBox的用法；也可以通过设置controller的更多属性，来支持传入更多配置例如按钮文案、按钮数量等等，还可以将参数本身设置为响应式对象，可以使MessageBox动态展示正在加载的进度等等，整个使用流程和逻辑更符合Vue的思考方式。</p><p>我把这个组件构建思路应用在了Cent中，这样每个组件都只需要关心自己的工作，不再需要处理额外的状态来管理MessageBox弹窗，整个逻辑条理清晰，十分利于维护。</p><h2 level="2" id="思考">思考</h2><p>ElMessageBox采用手动构建和挂载DOM的方式还有另外一层因素，就是多层嵌套的MessageBox，例如二次确认或者多次确认，这时单个MessageBox组件就不够用了，那要如何处理这种情况呢？</p><p>其实解决方法也很简单，我们可以创建一个高阶组件，它专门负责创建重复的组件并自动为组件分配id和层级，把我们的MessageBox包裹起来，就可以了</p><div class="llt-code readonly"><div class="language">vue</div><div class="wrapper"><pre><code class="language-vue"><span class="xml" class="xml"><span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">component</span> <span class="hljs-attr" class="hljs-attr">v-for</span>=<span class="hljs-string" class="hljs-string">&quot;{component,props,key} in list&quot;</span> <span class="hljs-attr" class="hljs-attr">:key</span>=<span class="hljs-string" class="hljs-string">&quot;key&quot;</span> <span class="hljs-attr" class="hljs-attr">:is</span>=<span class="hljs-string" class="hljs-string">&quot;component&quot;</span> <span class="hljs-attr" class="hljs-attr">v-bind</span>=<span class="hljs-string" class="hljs-string">&quot;props&quot;</span> /&gt;</span>
<span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag" class="hljs-tag">&lt;<span class="hljs-name" class="hljs-name">script</span> <span class="hljs-attr" class="hljs-attr">lang</span>=<span class="hljs-string" class="hljs-string">&quot;ts&quot;</span> <span class="hljs-attr" class="hljs-attr">setup</span>&gt;</span><span class="javascript" class="javascript">
<span class="hljs-keyword" class="hljs-keyword">import</span> type { <span class="hljs-title,class_" class="hljs-title,class_">Component</span> } <span class="hljs-keyword" class="hljs-keyword">from</span> <span class="hljs-string" class="hljs-string">&apos;vue&apos;</span>;

defineProps&lt;{
    <span class="hljs-attr" class="hljs-attr">list</span>:{
        <span class="hljs-attr" class="hljs-attr">component</span>:<span class="hljs-title,class_" class="hljs-title,class_">Component</span>,
        <span class="hljs-attr" class="hljs-attr">props</span>:any,
        <span class="hljs-attr" class="hljs-attr">key</span>:string
    }[]
}&gt;()
</span><span class="hljs-tag" class="hljs-tag">&lt;/<span class="hljs-name" class="hljs-name">script</span>&gt;</span>
</span></code></pre></div></div><p>不过同样的，这样也会导致MessageBox失去对自定义slot的支持。大多数情况下，二次确认的弹窗数量不会超过两个因此完全可以将二次确认的MessageBox放在根组件中，而将首次弹窗的MessageBox放在当前的组件，这样也更方便理解逻辑。</p><h2 level="2" id="Vue的不足">Vue的不足</h2><p>描述Vue和React、Angular之类的框架优劣之争已经有了很多说法，不过我在使用Vue的过程中最大一个痛点就是Vue的单文件写法，单文件在代码组织方面是有优势的，可以方便区分不同的组件，做到许多编译期的优化，但是一个Vue文件只能有一个组件的设计也让我不得不写很多额外的临时组件，例如渲染一个只会在当前组件用到的列表，我实在不想为了单独的列表项目去想一个新名字，为这些临时组件新建一个文件夹，再多写好几遍import、export语句。在react或者其他JSX语言的框架中，我可以把这些临时组件写在一个文件里，随时调用，当然vue也提供了JSX的写法，但是那样就会失去编译器的模板优化，并且vue的JSX与其他框架的语义并不完全相同，一些特殊的用法还得重新学习，显然算不上优雅的解决方法。</p><script type="module">const injectHtml = (root, html) => {
  const iframe = document.createElement("iframe");
  const htmlContent = `<html><head></head><body>${html}</body></html>`;
  iframe.style.width = "100%";
  iframe.style.height = "100%";
  iframe.onload = () => {
    const doc = iframe.contentDocument || iframe.contentWindow?.document;
    if (!doc) {
      return;
    }
    doc.open();
    doc.write(htmlContent);
    doc.close();
  };
  root.replaceChildren(iframe);
}
  document.querySelectorAll('.playground')?.forEach(el=>{
    const html = el.getAttribute('data-html');
    if (html) {
      injectHtml(el,html);
    }
    const indicator = document.createElement("div");
    indicator.className = "indicator";
    const showCode = document.createElement("div");
    showCode.className = "show-code";
    showCode.innerText = "code";
    showCode.onclick = () => {
      el.parentElement.classList.remove("preview-only");
    };
    const showPreview = document.createElement("div");
    showPreview.className = "show-preview";
    showPreview.innerText = "preview";
    showPreview.onclick = () => {
      el.parentElement.classList.add("preview-only");
    };
    indicator.appendChild(showCode);
    indicator.appendChild(showPreview);
    el.parentElement.appendChild(indicator);
    if (window.screen.width < 768) {
      showPreview.click();
    }
  });</script></div> <div data-page-id="2022年了如何写出优雅的vue3组件" class="navigator flex justify-between items-center mt-4 py-4"> <a href="/post/Discord-Bot" class="flex items-center gap-1 text-blue cursor-pointer flex-[45%]"> <div class="i-ri:arrow-left-double-line w-5 h-5 flex-shrink-0"></div> <div class="text-start">在浏览器中运行Discord Bot</div> </a> <a href="/post/撤销回退历史记录功能的思考" class="flex items-center justify-end gap-1 text-blue cursor-pointer flex-[45%]"> <div class="text-end">撤销回退历史记录功能的思考</div> <div class="i-ri:arrow-right-double-line w-5 h-5 flex-shrink-0"></div> </a> </div> </div> <div class="outline-wrapper"></div> </main> <div class="giscus-container flex justify-center"> <div class="w-full max-w-[870px] mx-8"> <script src="https://giscus.app/client.js" data-repo="glink25/glink25.github.io" data-repo-id="R_kgDONTJ_KQ" data-category="Announcements" data-category-id="DIC_kwDONTJ_Kc4Ckrg6" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script> </div> </div> <div class="mt-8 w-full flex flex-col items-center group"> <ul class="max-w-[720px] flex justify-center gap-6 [&_li]:opacity-60 [&_li:hover]:opacity-100 border-t border-t-[4px] border-t-double pt-4"> <li> <a href="/tag">Tags</a> </li> <li> <a href="https://github.com/glink25" target="_blank">About</a> </li> <li class="relative" tabindex="-1"> <div class="cursor-pointer">Tools</div> </li> </ul> <div class="group-focus-within:flex hidden flex-col gap-2 p-2 items-center [&>*]:opacity-60 [&>*:hover]:opacity-100 [&>*:hover]:underline [&>*:hover:after]:content-[1]"> <a href="https://oncent.github.io" target="_blank">Oncent - 多人记账PWA，无需服务器</a> <a href="https://peek-transfer.github.io" target="_blank">Peek - 点对点快速传输文件</a> <a href="https://glink25.gitee.io" target="_blank">My Days - 倒数日</a> </div> </div> <footer class="flex justify-center"> <small class="w-full max-w-[720px] min-h-12 flex justify-center items-center opacity-60"> <a href="https://github.com/glink25" target="_blank">© Glink</a> </small> </footer> </body></html>